{"id":"a784db19ae81384c682cf004d9287c99","_format":"hh-sol-build-info-1","solcVersion":"0.8.20","solcLongVersion":"0.8.20+commit.a1b79de6","input":{"language":"Solidity","sources":{"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol":{"content":"// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\n */\ninterface IERC725Y is IERC165 {\n    /**\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\n     * @param dataKey The data key for which a bytes value is set.\n     * @param dataValue The value to set for the given data key.\n     */\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\n\n    /**\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\n     * @param dataKey The data key for which to retrieve the value.\n     * @return dataValue The bytes value stored under the specified data key.\n     */\n    function getData(\n        bytes32 dataKey\n    ) external view returns (bytes memory dataValue);\n\n    /**\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\n     * @param dataKeys The array of keys which values to retrieve\n     * @return dataValues The array of data stored at multiple keys\n     */\n    function getDataBatch(\n        bytes32[] memory dataKeys\n    ) external view returns (bytes[] memory dataValues);\n\n    /**\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\n     *\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\n     * a fee mechanism for setting specific data.\n     *\n     * @param dataKey The data key for which to set a new value.\n     * @param dataValue The new bytes value to set.\n     */\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\n\n    /**\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\n     *\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\n     *\n     * @param dataKeys An array of data keys to set bytes values for.\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\n     */\n    function setDataBatch(\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) external payable;\n}\n"},"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\nimport \"@lukso/lsp0-contracts/contracts/LSP0Constants.sol\";\n"},"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\nimport \"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\";\n"},"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\nimport \"@lukso/lsp1-contracts/contracts/LSP1Constants.sol\";\n"},"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\nimport \"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\";\n"},"@lukso/lsp0-contracts/contracts/LSP0Constants.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP0 = 0x24871b3d;\nbytes4 constant _INTERFACEID_ERC1271 = 0x1626ba7e;\n\n// ERC1271 - Standard Signature Validation\nbytes4 constant _ERC1271_SUCCESSVALUE = 0x1626ba7e;\nbytes4 constant _ERC1271_FAILVALUE = 0xffffffff;\n\n// --- Native Token Type Id\n\n// keccak256('LSP0ValueReceived')\nbytes32 constant _TYPEID_LSP0_VALUE_RECEIVED = 0x9c4705229491d365fb5434052e12a386d6771d976bea61070a8c694e8affea3d;\n\n// Ownership Transfer Type IDs\n\n// keccak256('LSP0OwnershipTransferStarted')\nbytes32 constant _TYPEID_LSP0_OwnershipTransferStarted = 0xe17117c9d2665d1dbeb479ed8058bbebde3c50ac50e2e65619f60006caac6926;\n\n// keccak256('LSP0OwnershipTransferred_SenderNotification')\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_SenderNotification = 0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814;\n\n// keccak256('LSP0OwnershipTransferred_RecipientNotification')\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_RecipientNotification = 0xceca317f109c43507871523e82dc2a3cc64dfa18f12da0b6db14f6e23f995538;\n"},"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n/**\n * @title Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.\n * @dev LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received.\n */\ninterface ILSP1UniversalReceiver {\n    /**\n     * @dev Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\n     * @notice Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\n     *\n     * @param from The address of the EOA or smart contract that called the {universalReceiver(...)} function.\n     * @param value The amount sent to the {universalReceiver(...)} function.\n     * @param typeId A `bytes32` unique identifier (= _\"hook\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\n     * @param receivedData Any arbitrary data that was sent to the {universalReceiver(...)} function.\n     * @param returnedValue The value returned by the {universalReceiver(...)} function.\n     */\n    event UniversalReceiver(\n        address indexed from,\n        uint256 indexed value,\n        bytes32 indexed typeId,\n        bytes receivedData,\n        bytes returnedValue\n    );\n\n    /**\n     * @dev Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\n     * @notice Reacted on received notification with `typeId` & `data`.\n     *\n     * @param typeId The hash of a specific standard or a hook.\n     * @param data The arbitrary data received with the call.\n     *\n     * @custom:events {UniversalReceiver} event.\n     */\n    function universalReceiver(\n        bytes32 typeId,\n        bytes calldata data\n    ) external payable returns (bytes memory);\n}\n"},"@lukso/lsp1-contracts/contracts/LSP1Constants.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP1 = 0x6bb56a14;\nbytes4 constant _INTERFACEID_LSP1_DELEGATE = 0xa245bbda;\n\n// --- ERC725Y Data Keys\n\n// bytes10(keccak256('LSP1UniversalReceiverDelegate'))\nbytes10 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX = 0x0cfc51aec37c55a4d0b1;\n\n// keccak256('LSP1UniversalReceiverDelegate')\nbytes32 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY = 0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47;\n"},"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\n\n/**\n * @title Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.\n */\ninterface ILSP8IdentifiableDigitalAsset is IERC165, IERC725Y {\n    // --- Events\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from the `from` to the `to` address.\n     * @param operator The address of operator that sent the `tokenId`\n     * @param from The previous owner of the `tokenId`\n     * @param to The new owner of `tokenId`\n     * @param tokenId The tokenId that was transferred\n     * @param force If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\n     * @param data Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\n     */\n    event Transfer(\n        address operator,\n        address indexed from,\n        address indexed to,\n        bytes32 indexed tokenId,\n        bool force,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\n     * @param operator The address authorized as an operator.\n     * @param tokenOwner The owner of the `tokenId`.\n     * @param tokenId The tokenId `operator` address has access on behalf of `tokenOwner`.\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     */\n    event OperatorAuthorizationChanged(\n        address indexed operator,\n        address indexed tokenOwner,\n        bytes32 indexed tokenId,\n        bytes operatorNotificationData\n    );\n\n    /**\n     * @dev Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\n     * @param operator The address revoked from the operator array ({getOperatorsOf}).\n     * @param tokenOwner The owner of the `tokenId`.\n     * @param tokenId The tokenId `operator` is revoked from operating on.\n     * @param notified Bool indicating whether the operator has been notified or not\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     */\n    event OperatorRevoked(\n        address indexed operator,\n        address indexed tokenOwner,\n        bytes32 indexed tokenId,\n        bool notified,\n        bytes operatorNotificationData\n    );\n\n    /**\n     * @dev Emitted when setting data for `tokenId`.\n     * @param tokenId The tokenId which data is set for.\n     * @param dataKey The data key for which a bytes value is set.\n     * @param dataValue The value to set for the given data key.\n     */\n    event TokenIdDataChanged(\n        bytes32 indexed tokenId,\n        bytes32 indexed dataKey,\n        bytes dataValue\n    );\n\n    // --- Token queries\n\n    /**\n     * @dev Returns the number of existing tokens that have been minted in this contract.\n     * @return The number of existing tokens.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // --- Token owner queries\n\n    /**\n     * @dev Get the number of token IDs owned by `tokenOwner`.\n\n     * @param tokenOwner The address to query     *\n     * @return The total number of token IDs that `tokenOwner` owns.\n     */\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    /**\n     * @dev Returns the address that owns a given `tokenId`.\n     *\n     * @param tokenId The token ID to query the owner for.\n     * @return The owner address of the given `tokenId`.\n     *\n     * @custom:requirements `tokenId` must exist.\n     * @custom:info if the `tokenId` is not owned by any address, the returned address will be `address(0)`\n     */\n    function tokenOwnerOf(bytes32 tokenId) external view returns (address);\n\n    /**\n     * @dev Returns the list of token IDs that the `tokenOwner` address owns.\n     * @param tokenOwner The address that we want to get the list of token IDs for.\n     * @return An array of `bytes32[] tokenIds` owned by `tokenOwner`.\n     */\n    function tokenIdsOf(\n        address tokenOwner\n    ) external view returns (bytes32[] memory);\n\n    // --- TokenId Metadata functionality\n\n    /**\n     * @notice Retrieves data for a specific `tokenId` and `dataKey`.\n     * @param tokenId The unique identifier for a token.\n     * @param dataKey The key for the data to retrieve.\n     * @return dataValues The data value associated with the given `tokenId` and `dataKey`.\n     */\n    function getDataForTokenId(\n        bytes32 tokenId,\n        bytes32 dataKey\n    ) external returns (bytes memory dataValues);\n\n    /**\n     * @notice Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\n     * @param tokenIds An array of token IDs.\n     * @param dataKeys An array of data keys corresponding to the token IDs.\n     * @return dataValues An array of data values for each pair of `tokenId` and `dataKey`.\n     */\n    function getDataBatchForTokenIds(\n        bytes32[] memory tokenIds,\n        bytes32[] memory dataKeys\n    ) external returns (bytes[] memory dataValues);\n\n    /**\n     * @notice Sets data for a specific `tokenId` and `dataKey`.\n     * @param tokenId The unique identifier for a token.\n     * @param dataKey The key for the data to set.\n     * @param dataValue The value to set for the given data key.\n     * @custom:events {TokenIdDataChanged} event.\n     */\n    function setDataForTokenId(\n        bytes32 tokenId,\n        bytes32 dataKey,\n        bytes memory dataValue\n    ) external;\n\n    /**\n     * @notice Sets data in batch for multiple `tokenId` and `dataKey` pairs.\n     * @param tokenIds An array of token IDs.\n     * @param dataKeys An array of data keys corresponding to the token IDs.\n     * @param dataValues An array of values to set for the given data keys.\n     * @custom:events {TokenIdDataChanged} event for each pair.\n     */\n    function setDataBatchForTokenIds(\n        bytes32[] memory tokenIds,\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) external;\n\n    // --- Operator functionality\n\n    /**\n     * @dev Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}.\n     * Notify the operator based on the LSP1-UniversalReceiver standard\n     *\n     * @param operator The address to authorize as an operator.\n     * @param tokenId The token ID operator has access to.\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     *\n     * @custom:requirements\n     * - `tokenId` must exist.\n     * - caller MUST be the {tokenOwnerOf} `tokenId`.\n     * - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address).\n     * - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorAuthorizationChanged} event.\n     */\n    function authorizeOperator(\n        address operator,\n        bytes32 tokenId,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @dev Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner.\n     * See also {isOperatorFor}.\n     *\n     * @param operator The address to revoke as an operator.\n     * @param tokenId The tokenId `operator` is revoked from operating on.\n     * @param notify Boolean indicating whether to notify the operator or not\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\n     *\n     * @custom:requirements\n     * - `tokenId` must exist.\n     * - caller must be the {tokenOwnerOf} `tokenId`.\n     * - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address).\n     * - `operator` cannot be the zero address.\n     *\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\n     */\n    function revokeOperator(\n        address operator,\n        bytes32 tokenId,\n        bool notify,\n        bytes memory operatorNotificationData\n    ) external;\n\n    /**\n     * @dev Returns whether `operator` address is an operator for a given `tokenId`.\n     *\n     * @param operator The address to query operator status for.\n     * @param tokenId The token ID to check if `operator` is allowed to operate on.\n     *\n     * @return `true` if `operator` is an operator for `tokenId`, `false` otherwise.\n     *\n     * @custom:requirements\n     * - `tokenId` must exist.\n     * - caller must be the current {tokenOwnerOf} `tokenId`.\n     *\n     * @custom:info The tokenOwner is its own operator.\n     */\n    function isOperatorFor(\n        address operator,\n        bytes32 tokenId\n    ) external view returns (bool);\n\n    /**\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\n     *\n     * @param tokenId The token ID to get the operators for.\n     * @return An array of operators allowed to transfer or burn a specific `tokenId`.\n     *\n     * Requirements\n     * - `tokenId` must exist.\n     */\n    function getOperatorsOf(\n        bytes32 tokenId\n    ) external view returns (address[] memory);\n\n    // --- Transfer functionality\n\n    /**\n     * @dev Transfer a given `tokenId` token from the `from` address to the `to` address.\n     *\n     * If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred.\n     *\n     * The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs)\n     * or contracts that do not implement the LSP1 standard.\n     *\n     * @param from The address that owns the given `tokenId`.\n     * @param to The address that will receive the `tokenId`.\n     * @param tokenId The token ID to transfer.\n     * @param force When set to `true`, the `to` address CAN be any addres.\n     * When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\n     *\n     * @custom:requirements\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself).\n     * - `from` must own the given `tokenId`.\n     * - If the caller is not `from`, it must be an operator for the `tokenId`.\n     *\n     * @custom:events\n     * - {Transfer} event when the `tokenId` is successfully transferred.\n     *\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\n     *\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\n     *\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\n     * This even if the `force` was set to `true`.\n     */\n    function transfer(\n        address from,\n        address to,\n        bytes32 tokenId,\n        bool force,\n        bytes memory data\n    ) external;\n\n    /**\n     * @dev Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`.\n     * If any transfer fails, the whole call will revert.\n     *\n     * @param from An array of sending addresses.\n     * @param to An array of recipient addresses.\n     * @param tokenId An array of token IDs to transfer.\n     * @param force When set to `true`, `to` may be any address.\n     * When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\n     *\n     *\n     * @custom:requirements\n     * - The arrays of `from`, `to` and `tokenId` must have the same length.\n     * - no values in the `from` array can be the zero address.\n     * - no values in the `to` array can be the zero address.\n     * - `from` and `to` cannot be the same address at the same index on each arrays.\n     * - each `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be an operator of each `tokenId`.\n     *\n     * @custom:events\n     * - {Transfer} events on each successful token transfer.\n     */\n    function transferBatch(\n        address[] memory from,\n        address[] memory to,\n        bytes32[] memory tokenId,\n        bool[] memory force,\n        bytes[] memory data\n    ) external;\n\n    /**\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\n     *\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\n     * @param data An array of ABI encoded function calls to be called on the contract.\n     * @return results An array of abi-encoded data returned by the functions executed.\n     */\n    function batchCalls(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"},"@openzeppelin/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"contracts/interfaces/IShirts.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {ILSP8IdentifiableDigitalAsset as ILSP8} from \"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\";\ninterface IShirts is ILSP8 {\n    event ShirtsMinted(address _recipient, uint256 _amount);\n\n    function mint(\n        address _recipient,\n        uint256 _amount\n    ) external payable;\n    \n    function getPrizePool() external view returns (address prizePool);\n\n    function getPrice() external view returns (uint256 price);\n}"},"contracts/mocks/UPMock.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    ILSP1UniversalReceiver\n} from \"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\";\n\n// modules\nimport {\n    ERC165\n} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n// constants\nimport {_INTERFACEID_LSP1} from \"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol\";\nimport {_INTERFACEID_LSP0} from \"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol\";\n\nimport {IShirts} from \"../interfaces/IShirts.sol\";\n\ninterface BPunX {\n    function mint(uint256 _amount) external payable;\n}\ncontract UPMock is ERC165, ILSP1UniversalReceiver {\n    \n    /// override the supportsInterface function from ERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == _INTERFACEID_LSP1 ||\n            interfaceId == _INTERFACEID_LSP0 ||\n            super.supportsInterface(interfaceId);\n    }\n    function universalReceiver(\n        bytes32 typeId,\n        bytes memory data\n    ) external payable override returns (bytes memory returnValue) {\n        emit UniversalReceiver(msg.sender, msg.value, typeId, data, \"\");\n\n        return \"thanks for calling\";\n    }\n    /**\n     * @notice Verifies that the signer is the owner of the signing contract.\n     */\n    function isValidSignature(\n        bytes32 /* messageHash */,\n        bytes calldata /* signature */\n    ) external pure returns (bytes4) {\n        // always return true (just for testing)\n        return 0x1626ba7e;\n    }\n    function transfer(\n        address shirts,\n        address from,\n        address to,\n        bytes32 tokenId,\n        bool force,\n        bytes memory data\n    ) external {\n        IShirts(shirts).transfer(from, to, tokenId, force, data);\n    }\n    function fund() external payable {}\n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n    receive() external payable {}\n    fallback() external payable {}\n}"}},"settings":{"optimizer":{"enabled":true,"runs":200},"evmVersion":"paris","outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","devdoc","userdoc","storageLayout","evm.gasEstimates"],"":["ast"]}},"metadata":{"useLiteralContent":true}}},"output":{"sources":{"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol":{"ast":{"absolutePath":"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol","exportedSymbols":{"IERC165":[386],"IERC725Y":[50]},"id":51,"license":"CC0-1.0","nodeType":"SourceUnit","nodes":[{"id":1,"literals":["solidity","^","0.8",".0"],"nodeType":"PragmaDirective","src":"36:23:0"},{"absolutePath":"@openzeppelin/contracts/utils/introspection/IERC165.sol","file":"@openzeppelin/contracts/utils/introspection/IERC165.sol","id":3,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":51,"sourceUnit":387,"src":"75:80:0","symbolAliases":[{"foreign":{"id":2,"name":"IERC165","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":386,"src":"83:7:0","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"abstract":false,"baseContracts":[{"baseName":{"id":5,"name":"IERC165","nameLocations":["502:7:0"],"nodeType":"IdentifierPath","referencedDeclaration":386,"src":"502:7:0"},"id":6,"nodeType":"InheritanceSpecifier","src":"502:7:0"}],"canonicalName":"IERC725Y","contractDependencies":[],"contractKind":"interface","documentation":{"id":4,"nodeType":"StructuredDocumentation","src":"157:322:0","text":" @title The interface for ERC725Y sub-standard, a generic data key/value store.\n @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\n It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage."},"fullyImplemented":false,"id":50,"linearizedBaseContracts":[50,386],"name":"IERC725Y","nameLocation":"490:8:0","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":{"id":7,"nodeType":"StructuredDocumentation","src":"516:373:0","text":" @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\n @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\n @param dataKey The data key for which a bytes value is set.\n @param dataValue The value to set for the given data key."},"eventSelector":"ece574603820d07bc9b91f2a932baadf4628aabcb8afba49776529c14a6104b2","id":13,"name":"DataChanged","nameLocation":"900:11:0","nodeType":"EventDefinition","parameters":{"id":12,"nodeType":"ParameterList","parameters":[{"constant":false,"id":9,"indexed":true,"mutability":"mutable","name":"dataKey","nameLocation":"928:7:0","nodeType":"VariableDeclaration","scope":13,"src":"912:23:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":8,"name":"bytes32","nodeType":"ElementaryTypeName","src":"912:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":11,"indexed":false,"mutability":"mutable","name":"dataValue","nameLocation":"943:9:0","nodeType":"VariableDeclaration","scope":13,"src":"937:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":10,"name":"bytes","nodeType":"ElementaryTypeName","src":"937:5:0","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"911:42:0"},"src":"894:60:0"},{"documentation":{"id":14,"nodeType":"StructuredDocumentation","src":"960:361:0","text":" @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\n @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\n @param dataKey The data key for which to retrieve the value.\n @return dataValue The bytes value stored under the specified data key."},"functionSelector":"54f6127f","id":21,"implemented":false,"kind":"function","modifiers":[],"name":"getData","nameLocation":"1335:7:0","nodeType":"FunctionDefinition","parameters":{"id":17,"nodeType":"ParameterList","parameters":[{"constant":false,"id":16,"mutability":"mutable","name":"dataKey","nameLocation":"1360:7:0","nodeType":"VariableDeclaration","scope":21,"src":"1352:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":15,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1352:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"1342:31:0"},"returnParameters":{"id":20,"nodeType":"ParameterList","parameters":[{"constant":false,"id":19,"mutability":"mutable","name":"dataValue","nameLocation":"1410:9:0","nodeType":"VariableDeclaration","scope":21,"src":"1397:22:0","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":18,"name":"bytes","nodeType":"ElementaryTypeName","src":"1397:5:0","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1396:24:0"},"scope":50,"src":"1326:95:0","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":22,"nodeType":"StructuredDocumentation","src":"1427:353:0","text":" @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\n @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\n @param dataKeys The array of keys which values to retrieve\n @return dataValues The array of data stored at multiple keys"},"functionSelector":"dedff9c6","id":31,"implemented":false,"kind":"function","modifiers":[],"name":"getDataBatch","nameLocation":"1794:12:0","nodeType":"FunctionDefinition","parameters":{"id":26,"nodeType":"ParameterList","parameters":[{"constant":false,"id":25,"mutability":"mutable","name":"dataKeys","nameLocation":"1833:8:0","nodeType":"VariableDeclaration","scope":31,"src":"1816:25:0","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":23,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1816:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":24,"nodeType":"ArrayTypeName","src":"1816:9:0","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"1806:41:0"},"returnParameters":{"id":30,"nodeType":"ParameterList","parameters":[{"constant":false,"id":29,"mutability":"mutable","name":"dataValues","nameLocation":"1886:10:0","nodeType":"VariableDeclaration","scope":31,"src":"1871:25:0","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":27,"name":"bytes","nodeType":"ElementaryTypeName","src":"1871:5:0","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":28,"nodeType":"ArrayTypeName","src":"1871:7:0","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"1870:27:0"},"scope":50,"src":"1785:113:0","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":32,"nodeType":"StructuredDocumentation","src":"1904:536:0","text":" @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\n @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\n The function is marked as payable to enable flexibility on child contracts. For instance to implement\n a fee mechanism for setting specific data.\n @param dataKey The data key for which to set a new value.\n @param dataValue The new bytes value to set."},"functionSelector":"7f23690c","id":39,"implemented":false,"kind":"function","modifiers":[],"name":"setData","nameLocation":"2454:7:0","nodeType":"FunctionDefinition","parameters":{"id":37,"nodeType":"ParameterList","parameters":[{"constant":false,"id":34,"mutability":"mutable","name":"dataKey","nameLocation":"2470:7:0","nodeType":"VariableDeclaration","scope":39,"src":"2462:15:0","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":33,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2462:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":36,"mutability":"mutable","name":"dataValue","nameLocation":"2492:9:0","nodeType":"VariableDeclaration","scope":39,"src":"2479:22:0","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":35,"name":"bytes","nodeType":"ElementaryTypeName","src":"2479:5:0","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"2461:41:0"},"returnParameters":{"id":38,"nodeType":"ParameterList","parameters":[],"src":"2519:0:0"},"scope":50,"src":"2445:75:0","stateMutability":"payable","virtual":false,"visibility":"external"},{"documentation":{"id":40,"nodeType":"StructuredDocumentation","src":"2526:478:0","text":" @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\n @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\n @param dataKeys An array of data keys to set bytes values for.\n @param dataValues An array of bytes values to set for each `dataKeys`."},"functionSelector":"97902421","id":49,"implemented":false,"kind":"function","modifiers":[],"name":"setDataBatch","nameLocation":"3018:12:0","nodeType":"FunctionDefinition","parameters":{"id":47,"nodeType":"ParameterList","parameters":[{"constant":false,"id":43,"mutability":"mutable","name":"dataKeys","nameLocation":"3057:8:0","nodeType":"VariableDeclaration","scope":49,"src":"3040:25:0","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":41,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3040:7:0","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":42,"nodeType":"ArrayTypeName","src":"3040:9:0","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":46,"mutability":"mutable","name":"dataValues","nameLocation":"3090:10:0","nodeType":"VariableDeclaration","scope":49,"src":"3075:25:0","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":44,"name":"bytes","nodeType":"ElementaryTypeName","src":"3075:5:0","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":45,"nodeType":"ArrayTypeName","src":"3075:7:0","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"3030:76:0"},"returnParameters":{"id":48,"nodeType":"ParameterList","parameters":[],"src":"3123:0:0"},"scope":50,"src":"3009:115:0","stateMutability":"payable","virtual":false,"visibility":"external"}],"scope":51,"src":"480:2646:0","usedErrors":[],"usedEvents":[13]}],"src":"36:3091:0"},"id":0},"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol":{"ast":{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol","exportedSymbols":{"_ERC1271_FAILVALUE":[76],"_ERC1271_SUCCESSVALUE":[73],"_INTERFACEID_ERC1271":[70],"_INTERFACEID_LSP0":[67],"_TYPEID_LSP0_OwnershipTransferStarted":[82],"_TYPEID_LSP0_OwnershipTransferred_RecipientNotification":[88],"_TYPEID_LSP0_OwnershipTransferred_SenderNotification":[85],"_TYPEID_LSP0_VALUE_RECEIVED":[79]},"id":54,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":52,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:1"},{"absolutePath":"@lukso/lsp0-contracts/contracts/LSP0Constants.sol","file":"@lukso/lsp0-contracts/contracts/LSP0Constants.sol","id":53,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":54,"sourceUnit":89,"src":"64:59:1","symbolAliases":[],"unitAlias":""}],"src":"39:85:1"},"id":1},"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol":{"ast":{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol","exportedSymbols":{"ILSP1UniversalReceiver":[115]},"id":57,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":55,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:2"},{"absolutePath":"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol","file":"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol","id":56,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":57,"sourceUnit":116,"src":"64:68:2","symbolAliases":[],"unitAlias":""}],"src":"39:94:2"},"id":2},"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol":{"ast":{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol","exportedSymbols":{"_INTERFACEID_LSP1":[120],"_INTERFACEID_LSP1_DELEGATE":[123],"_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY":[129],"_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX":[126]},"id":60,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":58,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:3"},{"absolutePath":"@lukso/lsp1-contracts/contracts/LSP1Constants.sol","file":"@lukso/lsp1-contracts/contracts/LSP1Constants.sol","id":59,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":60,"sourceUnit":130,"src":"64:59:3","symbolAliases":[],"unitAlias":""}],"src":"39:85:3"},"id":3},"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol":{"ast":{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol","exportedSymbols":{"IERC165":[386],"IERC725Y":[50],"ILSP8IdentifiableDigitalAsset":[350]},"id":63,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":61,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:4"},{"absolutePath":"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol","file":"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol","id":62,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":63,"sourceUnit":351,"src":"64:75:4","symbolAliases":[],"unitAlias":""}],"src":"39:101:4"},"id":4},"@lukso/lsp0-contracts/contracts/LSP0Constants.sol":{"ast":{"absolutePath":"@lukso/lsp0-contracts/contracts/LSP0Constants.sol","exportedSymbols":{"_ERC1271_FAILVALUE":[76],"_ERC1271_SUCCESSVALUE":[73],"_INTERFACEID_ERC1271":[70],"_INTERFACEID_LSP0":[67],"_TYPEID_LSP0_OwnershipTransferStarted":[82],"_TYPEID_LSP0_OwnershipTransferred_RecipientNotification":[88],"_TYPEID_LSP0_OwnershipTransferred_SenderNotification":[85],"_TYPEID_LSP0_VALUE_RECEIVED":[79]},"id":89,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":64,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:5"},{"constant":true,"id":67,"mutability":"constant","name":"_INTERFACEID_LSP0","nameLocation":"108:17:5","nodeType":"VariableDeclaration","scope":89,"src":"92:46:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":65,"name":"bytes4","nodeType":"ElementaryTypeName","src":"92:6:5","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"value":{"hexValue":"30783234383731623364","id":66,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"128:10:5","typeDescriptions":{"typeIdentifier":"t_rational_612834109_by_1","typeString":"int_const 612834109"},"value":"0x24871b3d"},"visibility":"internal"},{"constant":true,"id":70,"mutability":"constant","name":"_INTERFACEID_ERC1271","nameLocation":"156:20:5","nodeType":"VariableDeclaration","scope":89,"src":"140:49:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":68,"name":"bytes4","nodeType":"ElementaryTypeName","src":"140:6:5","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"value":{"hexValue":"30783136323662613765","id":69,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"179:10:5","typeDescriptions":{"typeIdentifier":"t_rational_371636862_by_1","typeString":"int_const 371636862"},"value":"0x1626ba7e"},"visibility":"internal"},{"constant":true,"id":73,"mutability":"constant","name":"_ERC1271_SUCCESSVALUE","nameLocation":"251:21:5","nodeType":"VariableDeclaration","scope":89,"src":"235:50:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":71,"name":"bytes4","nodeType":"ElementaryTypeName","src":"235:6:5","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"value":{"hexValue":"30783136323662613765","id":72,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"275:10:5","typeDescriptions":{"typeIdentifier":"t_rational_371636862_by_1","typeString":"int_const 371636862"},"value":"0x1626ba7e"},"visibility":"internal"},{"constant":true,"id":76,"mutability":"constant","name":"_ERC1271_FAILVALUE","nameLocation":"303:18:5","nodeType":"VariableDeclaration","scope":89,"src":"287:47:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":74,"name":"bytes4","nodeType":"ElementaryTypeName","src":"287:6:5","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"value":{"hexValue":"30786666666666666666","id":75,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"324:10:5","typeDescriptions":{"typeIdentifier":"t_rational_4294967295_by_1","typeString":"int_const 4294967295"},"value":"0xffffffff"},"visibility":"internal"},{"constant":true,"id":79,"mutability":"constant","name":"_TYPEID_LSP0_VALUE_RECEIVED","nameLocation":"417:27:5","nodeType":"VariableDeclaration","scope":89,"src":"400:113:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":77,"name":"bytes32","nodeType":"ElementaryTypeName","src":"400:7:5","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":{"hexValue":"307839633437303532323934393164333635666235343334303532653132613338366436373731643937366265613631303730613863363934653861666665613364","id":78,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"447:66:5","typeDescriptions":{"typeIdentifier":"t_rational_70686285961604950920806211732789936779336649279463392163660348800248498350653_by_1","typeString":"int_const 7068...(69 digits omitted)...0653"},"value":"0x9c4705229491d365fb5434052e12a386d6771d976bea61070a8c694e8affea3d"},"visibility":"internal"},{"constant":true,"id":82,"mutability":"constant","name":"_TYPEID_LSP0_OwnershipTransferStarted","nameLocation":"610:37:5","nodeType":"VariableDeclaration","scope":89,"src":"593:123:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":80,"name":"bytes32","nodeType":"ElementaryTypeName","src":"593:7:5","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":{"hexValue":"307865313731313763396432363635643164626562343739656438303538626265626465336335306163353065326536353631396636303030366361616336393236","id":81,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"650:66:5","typeDescriptions":{"typeIdentifier":"t_rational_101970208830827842342045397398428405290962075809797208835923719250899100264742_by_1","typeString":"int_const 1019...(70 digits omitted)...4742"},"value":"0xe17117c9d2665d1dbeb479ed8058bbebde3c50ac50e2e65619f60006caac6926"},"visibility":"internal"},{"constant":true,"id":85,"mutability":"constant","name":"_TYPEID_LSP0_OwnershipTransferred_SenderNotification","nameLocation":"796:52:5","nodeType":"VariableDeclaration","scope":89,"src":"779:138:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":83,"name":"bytes32","nodeType":"ElementaryTypeName","src":"779:7:5","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":{"hexValue":"307861346535396339333164313466376338613761333530323766393265653430623566323838366239666463646237386633306263356563636535613266383134","id":84,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"851:66:5","typeDescriptions":{"typeIdentifier":"t_rational_74584995784094879258197140902702068663775852884950847598921907427942938638356_by_1","typeString":"int_const 7458...(69 digits omitted)...8356"},"value":"0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814"},"visibility":"internal"},{"constant":true,"id":88,"mutability":"constant","name":"_TYPEID_LSP0_OwnershipTransferred_RecipientNotification","nameLocation":"1000:55:5","nodeType":"VariableDeclaration","scope":89,"src":"983:141:5","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":86,"name":"bytes32","nodeType":"ElementaryTypeName","src":"983:7:5","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":{"hexValue":"307863656361333137663130396334333530373837313532336538326463326133636336346466613138663132646130623664623134663665323366393935353338","id":87,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1058:66:5","typeDescriptions":{"typeIdentifier":"t_rational_93533691526471608619640232985592865632484953515781287531315828254921486587192_by_1","typeString":"int_const 9353...(69 digits omitted)...7192"},"value":"0xceca317f109c43507871523e82dc2a3cc64dfa18f12da0b6db14f6e23f995538"},"visibility":"internal"}],"src":"39:1087:5"},"id":5},"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol":{"ast":{"absolutePath":"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol","exportedSymbols":{"ILSP1UniversalReceiver":[115]},"id":116,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":90,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:6"},{"abstract":false,"baseContracts":[],"canonicalName":"ILSP1UniversalReceiver","contractDependencies":[],"contractKind":"interface","documentation":{"id":91,"nodeType":"StructuredDocumentation","src":"64:257:6","text":" @title Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.\n @dev LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received."},"fullyImplemented":false,"id":115,"linearizedBaseContracts":[115],"name":"ILSP1UniversalReceiver","nameLocation":"332:22:6","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":{"id":92,"nodeType":"StructuredDocumentation","src":"361:893:6","text":" @dev Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\n @notice Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\n @param from The address of the EOA or smart contract that called the {universalReceiver(...)} function.\n @param value The amount sent to the {universalReceiver(...)} function.\n @param typeId A `bytes32` unique identifier (= _\"hook\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\n @param receivedData Any arbitrary data that was sent to the {universalReceiver(...)} function.\n @param returnedValue The value returned by the {universalReceiver(...)} function."},"eventSelector":"9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2","id":104,"name":"UniversalReceiver","nameLocation":"1265:17:6","nodeType":"EventDefinition","parameters":{"id":103,"nodeType":"ParameterList","parameters":[{"constant":false,"id":94,"indexed":true,"mutability":"mutable","name":"from","nameLocation":"1308:4:6","nodeType":"VariableDeclaration","scope":104,"src":"1292:20:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":93,"name":"address","nodeType":"ElementaryTypeName","src":"1292:7:6","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":96,"indexed":true,"mutability":"mutable","name":"value","nameLocation":"1338:5:6","nodeType":"VariableDeclaration","scope":104,"src":"1322:21:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":95,"name":"uint256","nodeType":"ElementaryTypeName","src":"1322:7:6","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":98,"indexed":true,"mutability":"mutable","name":"typeId","nameLocation":"1369:6:6","nodeType":"VariableDeclaration","scope":104,"src":"1353:22:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":97,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1353:7:6","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":100,"indexed":false,"mutability":"mutable","name":"receivedData","nameLocation":"1391:12:6","nodeType":"VariableDeclaration","scope":104,"src":"1385:18:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":99,"name":"bytes","nodeType":"ElementaryTypeName","src":"1385:5:6","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"},{"constant":false,"id":102,"indexed":false,"mutability":"mutable","name":"returnedValue","nameLocation":"1419:13:6","nodeType":"VariableDeclaration","scope":104,"src":"1413:19:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":101,"name":"bytes","nodeType":"ElementaryTypeName","src":"1413:5:6","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1282:156:6"},"src":"1259:180:6"},{"documentation":{"id":105,"nodeType":"StructuredDocumentation","src":"1445:517:6","text":" @dev Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\n @notice Reacted on received notification with `typeId` & `data`.\n @param typeId The hash of a specific standard or a hook.\n @param data The arbitrary data received with the call.\n @custom:events {UniversalReceiver} event."},"functionSelector":"6bb56a14","id":114,"implemented":false,"kind":"function","modifiers":[],"name":"universalReceiver","nameLocation":"1976:17:6","nodeType":"FunctionDefinition","parameters":{"id":110,"nodeType":"ParameterList","parameters":[{"constant":false,"id":107,"mutability":"mutable","name":"typeId","nameLocation":"2011:6:6","nodeType":"VariableDeclaration","scope":114,"src":"2003:14:6","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":106,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2003:7:6","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":109,"mutability":"mutable","name":"data","nameLocation":"2042:4:6","nodeType":"VariableDeclaration","scope":114,"src":"2027:19:6","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes"},"typeName":{"id":108,"name":"bytes","nodeType":"ElementaryTypeName","src":"2027:5:6","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1993:59:6"},"returnParameters":{"id":113,"nodeType":"ParameterList","parameters":[{"constant":false,"id":112,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":114,"src":"2079:12:6","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":111,"name":"bytes","nodeType":"ElementaryTypeName","src":"2079:5:6","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"2078:14:6"},"scope":115,"src":"1967:126:6","stateMutability":"payable","virtual":false,"visibility":"external"}],"scope":116,"src":"322:1773:6","usedErrors":[],"usedEvents":[104]}],"src":"39:2057:6"},"id":6},"@lukso/lsp1-contracts/contracts/LSP1Constants.sol":{"ast":{"absolutePath":"@lukso/lsp1-contracts/contracts/LSP1Constants.sol","exportedSymbols":{"_INTERFACEID_LSP1":[120],"_INTERFACEID_LSP1_DELEGATE":[123],"_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY":[129],"_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX":[126]},"id":130,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":117,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:7"},{"constant":true,"id":120,"mutability":"constant","name":"_INTERFACEID_LSP1","nameLocation":"108:17:7","nodeType":"VariableDeclaration","scope":130,"src":"92:46:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":118,"name":"bytes4","nodeType":"ElementaryTypeName","src":"92:6:7","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"value":{"hexValue":"30783662623536613134","id":119,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"128:10:7","typeDescriptions":{"typeIdentifier":"t_rational_1807051284_by_1","typeString":"int_const 1807051284"},"value":"0x6bb56a14"},"visibility":"internal"},{"constant":true,"id":123,"mutability":"constant","name":"_INTERFACEID_LSP1_DELEGATE","nameLocation":"156:26:7","nodeType":"VariableDeclaration","scope":130,"src":"140:55:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":121,"name":"bytes4","nodeType":"ElementaryTypeName","src":"140:6:7","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"value":{"hexValue":"30786132343562626461","id":122,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"185:10:7","typeDescriptions":{"typeIdentifier":"t_rational_2722479066_by_1","typeString":"int_const 2722479066"},"value":"0xa245bbda"},"visibility":"internal"},{"constant":true,"id":126,"mutability":"constant","name":"_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX","nameLocation":"296:40:7","nodeType":"VariableDeclaration","scope":130,"src":"279:82:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes10","typeString":"bytes10"},"typeName":{"id":124,"name":"bytes10","nodeType":"ElementaryTypeName","src":"279:7:7","typeDescriptions":{"typeIdentifier":"t_bytes10","typeString":"bytes10"}},"value":{"hexValue":"30783063666335316165633337633535613464306231","id":125,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"339:22:7","typeDescriptions":{"typeIdentifier":"t_rational_61322863157712349614257_by_1","typeString":"int_const 61322863157712349614257"},"value":"0x0cfc51aec37c55a4d0b1"},"visibility":"internal"},{"constant":true,"id":129,"mutability":"constant","name":"_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY","nameLocation":"427:37:7","nodeType":"VariableDeclaration","scope":130,"src":"410:123:7","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":127,"name":"bytes32","nodeType":"ElementaryTypeName","src":"410:7:7","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"value":{"hexValue":"307830636663353161656333376335356134643062316136356336323535633462663266626466363237376633636330373330633435623832386236646238623437","id":128,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"467:66:7","typeDescriptions":{"typeIdentifier":"t_rational_5873563396395204772354203425660447968463963513255343663932314865640255753031_by_1","typeString":"int_const 5873...(68 digits omitted)...3031"},"value":"0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47"},"visibility":"internal"}],"src":"39:496:7"},"id":7},"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol":{"ast":{"absolutePath":"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol","exportedSymbols":{"IERC165":[386],"IERC725Y":[50],"ILSP8IdentifiableDigitalAsset":[350]},"id":351,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":131,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:8"},{"absolutePath":"@openzeppelin/contracts/utils/introspection/IERC165.sol","file":"@openzeppelin/contracts/utils/introspection/IERC165.sol","id":133,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":351,"sourceUnit":387,"src":"78:80:8","symbolAliases":[{"foreign":{"id":132,"name":"IERC165","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":386,"src":"86:7:8","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"absolutePath":"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol","file":"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol","id":135,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":351,"sourceUnit":51,"src":"159:89:8","symbolAliases":[{"foreign":{"id":134,"name":"IERC725Y","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":50,"src":"172:8:8","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"abstract":false,"baseContracts":[{"baseName":{"id":137,"name":"IERC165","nameLocations":["402:7:8"],"nodeType":"IdentifierPath","referencedDeclaration":386,"src":"402:7:8"},"id":138,"nodeType":"InheritanceSpecifier","src":"402:7:8"},{"baseName":{"id":139,"name":"IERC725Y","nameLocations":["411:8:8"],"nodeType":"IdentifierPath","referencedDeclaration":50,"src":"411:8:8"},"id":140,"nodeType":"InheritanceSpecifier","src":"411:8:8"}],"canonicalName":"ILSP8IdentifiableDigitalAsset","contractDependencies":[],"contractKind":"interface","documentation":{"id":136,"nodeType":"StructuredDocumentation","src":"250:108:8","text":" @title Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset."},"fullyImplemented":false,"id":350,"linearizedBaseContracts":[350,50,386],"name":"ILSP8IdentifiableDigitalAsset","nameLocation":"369:29:8","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"documentation":{"id":141,"nodeType":"StructuredDocumentation","src":"445:616:8","text":" @dev Emitted when `tokenId` token is transferred from the `from` to the `to` address.\n @param operator The address of operator that sent the `tokenId`\n @param from The previous owner of the `tokenId`\n @param to The new owner of `tokenId`\n @param tokenId The tokenId that was transferred\n @param force If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\n @param data Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses."},"eventSelector":"b333c813a7426a7a11e2b190cad52c44119421594b47f6f32ace6d8c7207b2bf","id":155,"name":"Transfer","nameLocation":"1072:8:8","nodeType":"EventDefinition","parameters":{"id":154,"nodeType":"ParameterList","parameters":[{"constant":false,"id":143,"indexed":false,"mutability":"mutable","name":"operator","nameLocation":"1098:8:8","nodeType":"VariableDeclaration","scope":155,"src":"1090:16:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":142,"name":"address","nodeType":"ElementaryTypeName","src":"1090:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":145,"indexed":true,"mutability":"mutable","name":"from","nameLocation":"1132:4:8","nodeType":"VariableDeclaration","scope":155,"src":"1116:20:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":144,"name":"address","nodeType":"ElementaryTypeName","src":"1116:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":147,"indexed":true,"mutability":"mutable","name":"to","nameLocation":"1162:2:8","nodeType":"VariableDeclaration","scope":155,"src":"1146:18:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":146,"name":"address","nodeType":"ElementaryTypeName","src":"1146:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":149,"indexed":true,"mutability":"mutable","name":"tokenId","nameLocation":"1190:7:8","nodeType":"VariableDeclaration","scope":155,"src":"1174:23:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":148,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1174:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":151,"indexed":false,"mutability":"mutable","name":"force","nameLocation":"1212:5:8","nodeType":"VariableDeclaration","scope":155,"src":"1207:10:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":150,"name":"bool","nodeType":"ElementaryTypeName","src":"1207:4:8","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":153,"indexed":false,"mutability":"mutable","name":"data","nameLocation":"1233:4:8","nodeType":"VariableDeclaration","scope":155,"src":"1227:10:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":152,"name":"bytes","nodeType":"ElementaryTypeName","src":"1227:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1080:163:8"},"src":"1066:178:8"},{"anonymous":false,"documentation":{"id":156,"nodeType":"StructuredDocumentation","src":"1250:396:8","text":" @dev Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\n @param operator The address authorized as an operator.\n @param tokenOwner The owner of the `tokenId`.\n @param tokenId The tokenId `operator` address has access on behalf of `tokenOwner`.\n @param operatorNotificationData The data to notify the operator about via LSP1."},"eventSelector":"1b1b58aa2ec0cec2228b2d37124556d41f5a1f7b12f089171f896cc236671215","id":166,"name":"OperatorAuthorizationChanged","nameLocation":"1657:28:8","nodeType":"EventDefinition","parameters":{"id":165,"nodeType":"ParameterList","parameters":[{"constant":false,"id":158,"indexed":true,"mutability":"mutable","name":"operator","nameLocation":"1711:8:8","nodeType":"VariableDeclaration","scope":166,"src":"1695:24:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":157,"name":"address","nodeType":"ElementaryTypeName","src":"1695:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":160,"indexed":true,"mutability":"mutable","name":"tokenOwner","nameLocation":"1745:10:8","nodeType":"VariableDeclaration","scope":166,"src":"1729:26:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":159,"name":"address","nodeType":"ElementaryTypeName","src":"1729:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":162,"indexed":true,"mutability":"mutable","name":"tokenId","nameLocation":"1781:7:8","nodeType":"VariableDeclaration","scope":166,"src":"1765:23:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":161,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1765:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":164,"indexed":false,"mutability":"mutable","name":"operatorNotificationData","nameLocation":"1804:24:8","nodeType":"VariableDeclaration","scope":166,"src":"1798:30:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":163,"name":"bytes","nodeType":"ElementaryTypeName","src":"1798:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1685:149:8"},"src":"1651:184:8"},{"anonymous":false,"documentation":{"id":167,"nodeType":"StructuredDocumentation","src":"1841:501:8","text":" @dev Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\n @param operator The address revoked from the operator array ({getOperatorsOf}).\n @param tokenOwner The owner of the `tokenId`.\n @param tokenId The tokenId `operator` is revoked from operating on.\n @param notified Bool indicating whether the operator has been notified or not\n @param operatorNotificationData The data to notify the operator about via LSP1."},"eventSelector":"c78cd419d6136f9f1c1c6aec1d3fae098cffaf8bc86314a8f2685e32fe574e3c","id":179,"name":"OperatorRevoked","nameLocation":"2353:15:8","nodeType":"EventDefinition","parameters":{"id":178,"nodeType":"ParameterList","parameters":[{"constant":false,"id":169,"indexed":true,"mutability":"mutable","name":"operator","nameLocation":"2394:8:8","nodeType":"VariableDeclaration","scope":179,"src":"2378:24:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":168,"name":"address","nodeType":"ElementaryTypeName","src":"2378:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":171,"indexed":true,"mutability":"mutable","name":"tokenOwner","nameLocation":"2428:10:8","nodeType":"VariableDeclaration","scope":179,"src":"2412:26:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":170,"name":"address","nodeType":"ElementaryTypeName","src":"2412:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":173,"indexed":true,"mutability":"mutable","name":"tokenId","nameLocation":"2464:7:8","nodeType":"VariableDeclaration","scope":179,"src":"2448:23:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":172,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2448:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":175,"indexed":false,"mutability":"mutable","name":"notified","nameLocation":"2486:8:8","nodeType":"VariableDeclaration","scope":179,"src":"2481:13:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":174,"name":"bool","nodeType":"ElementaryTypeName","src":"2481:4:8","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":177,"indexed":false,"mutability":"mutable","name":"operatorNotificationData","nameLocation":"2510:24:8","nodeType":"VariableDeclaration","scope":179,"src":"2504:30:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":176,"name":"bytes","nodeType":"ElementaryTypeName","src":"2504:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"2368:172:8"},"src":"2347:194:8"},{"anonymous":false,"documentation":{"id":180,"nodeType":"StructuredDocumentation","src":"2547:253:8","text":" @dev Emitted when setting data for `tokenId`.\n @param tokenId The tokenId which data is set for.\n @param dataKey The data key for which a bytes value is set.\n @param dataValue The value to set for the given data key."},"eventSelector":"a6e4251f855f750545fe414f120db91c76b88def14d120969e5bb2d3f05debbb","id":188,"name":"TokenIdDataChanged","nameLocation":"2811:18:8","nodeType":"EventDefinition","parameters":{"id":187,"nodeType":"ParameterList","parameters":[{"constant":false,"id":182,"indexed":true,"mutability":"mutable","name":"tokenId","nameLocation":"2855:7:8","nodeType":"VariableDeclaration","scope":188,"src":"2839:23:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":181,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2839:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":184,"indexed":true,"mutability":"mutable","name":"dataKey","nameLocation":"2888:7:8","nodeType":"VariableDeclaration","scope":188,"src":"2872:23:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":183,"name":"bytes32","nodeType":"ElementaryTypeName","src":"2872:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":186,"indexed":false,"mutability":"mutable","name":"dataValue","nameLocation":"2911:9:8","nodeType":"VariableDeclaration","scope":188,"src":"2905:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":185,"name":"bytes","nodeType":"ElementaryTypeName","src":"2905:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"2829:97:8"},"src":"2805:122:8"},{"documentation":{"id":189,"nodeType":"StructuredDocumentation","src":"2959:147:8","text":" @dev Returns the number of existing tokens that have been minted in this contract.\n @return The number of existing tokens."},"functionSelector":"18160ddd","id":194,"implemented":false,"kind":"function","modifiers":[],"name":"totalSupply","nameLocation":"3120:11:8","nodeType":"FunctionDefinition","parameters":{"id":190,"nodeType":"ParameterList","parameters":[],"src":"3131:2:8"},"returnParameters":{"id":193,"nodeType":"ParameterList","parameters":[{"constant":false,"id":192,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":194,"src":"3157:7:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":191,"name":"uint256","nodeType":"ElementaryTypeName","src":"3157:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3156:9:8"},"scope":350,"src":"3111:55:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":195,"nodeType":"StructuredDocumentation","src":"3204:196:8","text":" @dev Get the number of token IDs owned by `tokenOwner`.\n @param tokenOwner The address to query     *\n @return The total number of token IDs that `tokenOwner` owns."},"functionSelector":"70a08231","id":202,"implemented":false,"kind":"function","modifiers":[],"name":"balanceOf","nameLocation":"3414:9:8","nodeType":"FunctionDefinition","parameters":{"id":198,"nodeType":"ParameterList","parameters":[{"constant":false,"id":197,"mutability":"mutable","name":"tokenOwner","nameLocation":"3432:10:8","nodeType":"VariableDeclaration","scope":202,"src":"3424:18:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":196,"name":"address","nodeType":"ElementaryTypeName","src":"3424:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3423:20:8"},"returnParameters":{"id":201,"nodeType":"ParameterList","parameters":[{"constant":false,"id":200,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":202,"src":"3467:7:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":199,"name":"uint256","nodeType":"ElementaryTypeName","src":"3467:7:8","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3466:9:8"},"scope":350,"src":"3405:71:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":203,"nodeType":"StructuredDocumentation","src":"3482:360:8","text":" @dev Returns the address that owns a given `tokenId`.\n @param tokenId The token ID to query the owner for.\n @return The owner address of the given `tokenId`.\n @custom:requirements `tokenId` must exist.\n @custom:info if the `tokenId` is not owned by any address, the returned address will be `address(0)`"},"functionSelector":"217b2270","id":210,"implemented":false,"kind":"function","modifiers":[],"name":"tokenOwnerOf","nameLocation":"3856:12:8","nodeType":"FunctionDefinition","parameters":{"id":206,"nodeType":"ParameterList","parameters":[{"constant":false,"id":205,"mutability":"mutable","name":"tokenId","nameLocation":"3877:7:8","nodeType":"VariableDeclaration","scope":210,"src":"3869:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":204,"name":"bytes32","nodeType":"ElementaryTypeName","src":"3869:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"3868:17:8"},"returnParameters":{"id":209,"nodeType":"ParameterList","parameters":[{"constant":false,"id":208,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":210,"src":"3909:7:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":207,"name":"address","nodeType":"ElementaryTypeName","src":"3909:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"3908:9:8"},"scope":350,"src":"3847:71:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":211,"nodeType":"StructuredDocumentation","src":"3924:244:8","text":" @dev Returns the list of token IDs that the `tokenOwner` address owns.\n @param tokenOwner The address that we want to get the list of token IDs for.\n @return An array of `bytes32[] tokenIds` owned by `tokenOwner`."},"functionSelector":"a3b261f2","id":219,"implemented":false,"kind":"function","modifiers":[],"name":"tokenIdsOf","nameLocation":"4182:10:8","nodeType":"FunctionDefinition","parameters":{"id":214,"nodeType":"ParameterList","parameters":[{"constant":false,"id":213,"mutability":"mutable","name":"tokenOwner","nameLocation":"4210:10:8","nodeType":"VariableDeclaration","scope":219,"src":"4202:18:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":212,"name":"address","nodeType":"ElementaryTypeName","src":"4202:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"4192:34:8"},"returnParameters":{"id":218,"nodeType":"ParameterList","parameters":[{"constant":false,"id":217,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":219,"src":"4250:16:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":215,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4250:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":216,"nodeType":"ArrayTypeName","src":"4250:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"4249:18:8"},"scope":350,"src":"4173:95:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":220,"nodeType":"StructuredDocumentation","src":"4317:286:8","text":" @notice Retrieves data for a specific `tokenId` and `dataKey`.\n @param tokenId The unique identifier for a token.\n @param dataKey The key for the data to retrieve.\n @return dataValues The data value associated with the given `tokenId` and `dataKey`."},"functionSelector":"16e023b3","id":229,"implemented":false,"kind":"function","modifiers":[],"name":"getDataForTokenId","nameLocation":"4617:17:8","nodeType":"FunctionDefinition","parameters":{"id":225,"nodeType":"ParameterList","parameters":[{"constant":false,"id":222,"mutability":"mutable","name":"tokenId","nameLocation":"4652:7:8","nodeType":"VariableDeclaration","scope":229,"src":"4644:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":221,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4644:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":224,"mutability":"mutable","name":"dataKey","nameLocation":"4677:7:8","nodeType":"VariableDeclaration","scope":229,"src":"4669:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":223,"name":"bytes32","nodeType":"ElementaryTypeName","src":"4669:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"4634:56:8"},"returnParameters":{"id":228,"nodeType":"ParameterList","parameters":[{"constant":false,"id":227,"mutability":"mutable","name":"dataValues","nameLocation":"4722:10:8","nodeType":"VariableDeclaration","scope":229,"src":"4709:23:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":226,"name":"bytes","nodeType":"ElementaryTypeName","src":"4709:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"4708:25:8"},"scope":350,"src":"4608:126:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":230,"nodeType":"StructuredDocumentation","src":"4740:309:8","text":" @notice Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\n @param tokenIds An array of token IDs.\n @param dataKeys An array of data keys corresponding to the token IDs.\n @return dataValues An array of data values for each pair of `tokenId` and `dataKey`."},"functionSelector":"1d26fce6","id":242,"implemented":false,"kind":"function","modifiers":[],"name":"getDataBatchForTokenIds","nameLocation":"5063:23:8","nodeType":"FunctionDefinition","parameters":{"id":237,"nodeType":"ParameterList","parameters":[{"constant":false,"id":233,"mutability":"mutable","name":"tokenIds","nameLocation":"5113:8:8","nodeType":"VariableDeclaration","scope":242,"src":"5096:25:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":231,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5096:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":232,"nodeType":"ArrayTypeName","src":"5096:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":236,"mutability":"mutable","name":"dataKeys","nameLocation":"5148:8:8","nodeType":"VariableDeclaration","scope":242,"src":"5131:25:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":234,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5131:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":235,"nodeType":"ArrayTypeName","src":"5131:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"}],"src":"5086:76:8"},"returnParameters":{"id":241,"nodeType":"ParameterList","parameters":[{"constant":false,"id":240,"mutability":"mutable","name":"dataValues","nameLocation":"5196:10:8","nodeType":"VariableDeclaration","scope":242,"src":"5181:25:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":238,"name":"bytes","nodeType":"ElementaryTypeName","src":"5181:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":239,"nodeType":"ArrayTypeName","src":"5181:7:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"5180:27:8"},"scope":350,"src":"5054:154:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":243,"nodeType":"StructuredDocumentation","src":"5214:299:8","text":" @notice Sets data for a specific `tokenId` and `dataKey`.\n @param tokenId The unique identifier for a token.\n @param dataKey The key for the data to set.\n @param dataValue The value to set for the given data key.\n @custom:events {TokenIdDataChanged} event."},"functionSelector":"d6c1407c","id":252,"implemented":false,"kind":"function","modifiers":[],"name":"setDataForTokenId","nameLocation":"5527:17:8","nodeType":"FunctionDefinition","parameters":{"id":250,"nodeType":"ParameterList","parameters":[{"constant":false,"id":245,"mutability":"mutable","name":"tokenId","nameLocation":"5562:7:8","nodeType":"VariableDeclaration","scope":252,"src":"5554:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":244,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5554:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":247,"mutability":"mutable","name":"dataKey","nameLocation":"5587:7:8","nodeType":"VariableDeclaration","scope":252,"src":"5579:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":246,"name":"bytes32","nodeType":"ElementaryTypeName","src":"5579:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":249,"mutability":"mutable","name":"dataValue","nameLocation":"5617:9:8","nodeType":"VariableDeclaration","scope":252,"src":"5604:22:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":248,"name":"bytes","nodeType":"ElementaryTypeName","src":"5604:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"5544:88:8"},"returnParameters":{"id":251,"nodeType":"ParameterList","parameters":[],"src":"5641:0:8"},"scope":350,"src":"5518:124:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":253,"nodeType":"StructuredDocumentation","src":"5648:352:8","text":" @notice Sets data in batch for multiple `tokenId` and `dataKey` pairs.\n @param tokenIds An array of token IDs.\n @param dataKeys An array of data keys corresponding to the token IDs.\n @param dataValues An array of values to set for the given data keys.\n @custom:events {TokenIdDataChanged} event for each pair."},"functionSelector":"be9f0e6f","id":265,"implemented":false,"kind":"function","modifiers":[],"name":"setDataBatchForTokenIds","nameLocation":"6014:23:8","nodeType":"FunctionDefinition","parameters":{"id":263,"nodeType":"ParameterList","parameters":[{"constant":false,"id":256,"mutability":"mutable","name":"tokenIds","nameLocation":"6064:8:8","nodeType":"VariableDeclaration","scope":265,"src":"6047:25:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":254,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6047:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":255,"nodeType":"ArrayTypeName","src":"6047:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":259,"mutability":"mutable","name":"dataKeys","nameLocation":"6099:8:8","nodeType":"VariableDeclaration","scope":265,"src":"6082:25:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":257,"name":"bytes32","nodeType":"ElementaryTypeName","src":"6082:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":258,"nodeType":"ArrayTypeName","src":"6082:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":262,"mutability":"mutable","name":"dataValues","nameLocation":"6132:10:8","nodeType":"VariableDeclaration","scope":265,"src":"6117:25:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":260,"name":"bytes","nodeType":"ElementaryTypeName","src":"6117:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":261,"nodeType":"ArrayTypeName","src":"6117:7:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"6037:111:8"},"returnParameters":{"id":264,"nodeType":"ParameterList","parameters":[],"src":"6157:0:8"},"scope":350,"src":"6005:153:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":266,"nodeType":"StructuredDocumentation","src":"6199:782:8","text":" @dev Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}.\n Notify the operator based on the LSP1-UniversalReceiver standard\n @param operator The address to authorize as an operator.\n @param tokenId The token ID operator has access to.\n @param operatorNotificationData The data to notify the operator about via LSP1.\n @custom:requirements\n - `tokenId` must exist.\n - caller MUST be the {tokenOwnerOf} `tokenId`.\n - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address).\n - `operator` cannot be the zero address.\n @custom:events {OperatorAuthorizationChanged} event."},"functionSelector":"86a10ddd","id":275,"implemented":false,"kind":"function","modifiers":[],"name":"authorizeOperator","nameLocation":"6995:17:8","nodeType":"FunctionDefinition","parameters":{"id":273,"nodeType":"ParameterList","parameters":[{"constant":false,"id":268,"mutability":"mutable","name":"operator","nameLocation":"7030:8:8","nodeType":"VariableDeclaration","scope":275,"src":"7022:16:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":267,"name":"address","nodeType":"ElementaryTypeName","src":"7022:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":270,"mutability":"mutable","name":"tokenId","nameLocation":"7056:7:8","nodeType":"VariableDeclaration","scope":275,"src":"7048:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":269,"name":"bytes32","nodeType":"ElementaryTypeName","src":"7048:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":272,"mutability":"mutable","name":"operatorNotificationData","nameLocation":"7086:24:8","nodeType":"VariableDeclaration","scope":275,"src":"7073:37:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":271,"name":"bytes","nodeType":"ElementaryTypeName","src":"7073:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"7012:104:8"},"returnParameters":{"id":274,"nodeType":"ParameterList","parameters":[],"src":"7125:0:8"},"scope":350,"src":"6986:140:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":276,"nodeType":"StructuredDocumentation","src":"7132:893:8","text":" @dev Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner.\n See also {isOperatorFor}.\n @param operator The address to revoke as an operator.\n @param tokenId The tokenId `operator` is revoked from operating on.\n @param notify Boolean indicating whether to notify the operator or not\n @param operatorNotificationData The data to notify the operator about via LSP1.\n @custom:requirements\n - `tokenId` must exist.\n - caller must be the {tokenOwnerOf} `tokenId`.\n - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address).\n - `operator` cannot be the zero address.\n @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token owner).."},"functionSelector":"db8c9663","id":287,"implemented":false,"kind":"function","modifiers":[],"name":"revokeOperator","nameLocation":"8039:14:8","nodeType":"FunctionDefinition","parameters":{"id":285,"nodeType":"ParameterList","parameters":[{"constant":false,"id":278,"mutability":"mutable","name":"operator","nameLocation":"8071:8:8","nodeType":"VariableDeclaration","scope":287,"src":"8063:16:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":277,"name":"address","nodeType":"ElementaryTypeName","src":"8063:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":280,"mutability":"mutable","name":"tokenId","nameLocation":"8097:7:8","nodeType":"VariableDeclaration","scope":287,"src":"8089:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":279,"name":"bytes32","nodeType":"ElementaryTypeName","src":"8089:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":282,"mutability":"mutable","name":"notify","nameLocation":"8119:6:8","nodeType":"VariableDeclaration","scope":287,"src":"8114:11:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":281,"name":"bool","nodeType":"ElementaryTypeName","src":"8114:4:8","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":284,"mutability":"mutable","name":"operatorNotificationData","nameLocation":"8148:24:8","nodeType":"VariableDeclaration","scope":287,"src":"8135:37:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":283,"name":"bytes","nodeType":"ElementaryTypeName","src":"8135:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"8053:125:8"},"returnParameters":{"id":286,"nodeType":"ParameterList","parameters":[],"src":"8187:0:8"},"scope":350,"src":"8030:158:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":288,"nodeType":"StructuredDocumentation","src":"8194:535:8","text":" @dev Returns whether `operator` address is an operator for a given `tokenId`.\n @param operator The address to query operator status for.\n @param tokenId The token ID to check if `operator` is allowed to operate on.\n @return `true` if `operator` is an operator for `tokenId`, `false` otherwise.\n @custom:requirements\n - `tokenId` must exist.\n - caller must be the current {tokenOwnerOf} `tokenId`.\n @custom:info The tokenOwner is its own operator."},"functionSelector":"2a3654a4","id":297,"implemented":false,"kind":"function","modifiers":[],"name":"isOperatorFor","nameLocation":"8743:13:8","nodeType":"FunctionDefinition","parameters":{"id":293,"nodeType":"ParameterList","parameters":[{"constant":false,"id":290,"mutability":"mutable","name":"operator","nameLocation":"8774:8:8","nodeType":"VariableDeclaration","scope":297,"src":"8766:16:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":289,"name":"address","nodeType":"ElementaryTypeName","src":"8766:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":292,"mutability":"mutable","name":"tokenId","nameLocation":"8800:7:8","nodeType":"VariableDeclaration","scope":297,"src":"8792:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":291,"name":"bytes32","nodeType":"ElementaryTypeName","src":"8792:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"8756:57:8"},"returnParameters":{"id":296,"nodeType":"ParameterList","parameters":[{"constant":false,"id":295,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":297,"src":"8837:4:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":294,"name":"bool","nodeType":"ElementaryTypeName","src":"8837:4:8","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"8836:6:8"},"scope":350,"src":"8734:109:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":298,"nodeType":"StructuredDocumentation","src":"8849:351:8","text":" @dev Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\n @param tokenId The token ID to get the operators for.\n @return An array of operators allowed to transfer or burn a specific `tokenId`.\n Requirements\n - `tokenId` must exist."},"functionSelector":"49a6078d","id":306,"implemented":false,"kind":"function","modifiers":[],"name":"getOperatorsOf","nameLocation":"9214:14:8","nodeType":"FunctionDefinition","parameters":{"id":301,"nodeType":"ParameterList","parameters":[{"constant":false,"id":300,"mutability":"mutable","name":"tokenId","nameLocation":"9246:7:8","nodeType":"VariableDeclaration","scope":306,"src":"9238:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":299,"name":"bytes32","nodeType":"ElementaryTypeName","src":"9238:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"}],"src":"9228:31:8"},"returnParameters":{"id":305,"nodeType":"ParameterList","parameters":[{"constant":false,"id":304,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":306,"src":"9283:16:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_memory_ptr","typeString":"address[]"},"typeName":{"baseType":{"id":302,"name":"address","nodeType":"ElementaryTypeName","src":"9283:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":303,"nodeType":"ArrayTypeName","src":"9283:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_storage_ptr","typeString":"address[]"}},"visibility":"internal"}],"src":"9282:18:8"},"scope":350,"src":"9205:96:8","stateMutability":"view","virtual":false,"visibility":"external"},{"documentation":{"id":307,"nodeType":"StructuredDocumentation","src":"9342:2075:8","text":" @dev Transfer a given `tokenId` token from the `from` address to the `to` address.\n If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred.\n The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs)\n or contracts that do not implement the LSP1 standard.\n @param from The address that owns the given `tokenId`.\n @param to The address that will receive the `tokenId`.\n @param tokenId The token ID to transfer.\n @param force When set to `true`, the `to` address CAN be any addres.\n When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\n @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\n @custom:requirements\n - `from` cannot be the zero address.\n - `to` cannot be the zero address.\n - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself).\n - `from` must own the given `tokenId`.\n - If the caller is not `from`, it must be an operator for the `tokenId`.\n @custom:events\n - {Transfer} event when the `tokenId` is successfully transferred.\n @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\n or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\n @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\n @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\n This even if the `force` was set to `true`."},"functionSelector":"511b6952","id":320,"implemented":false,"kind":"function","modifiers":[],"name":"transfer","nameLocation":"11431:8:8","nodeType":"FunctionDefinition","parameters":{"id":318,"nodeType":"ParameterList","parameters":[{"constant":false,"id":309,"mutability":"mutable","name":"from","nameLocation":"11457:4:8","nodeType":"VariableDeclaration","scope":320,"src":"11449:12:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":308,"name":"address","nodeType":"ElementaryTypeName","src":"11449:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":311,"mutability":"mutable","name":"to","nameLocation":"11479:2:8","nodeType":"VariableDeclaration","scope":320,"src":"11471:10:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":310,"name":"address","nodeType":"ElementaryTypeName","src":"11471:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":313,"mutability":"mutable","name":"tokenId","nameLocation":"11499:7:8","nodeType":"VariableDeclaration","scope":320,"src":"11491:15:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":312,"name":"bytes32","nodeType":"ElementaryTypeName","src":"11491:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":315,"mutability":"mutable","name":"force","nameLocation":"11521:5:8","nodeType":"VariableDeclaration","scope":320,"src":"11516:10:8","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":314,"name":"bool","nodeType":"ElementaryTypeName","src":"11516:4:8","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":317,"mutability":"mutable","name":"data","nameLocation":"11549:4:8","nodeType":"VariableDeclaration","scope":320,"src":"11536:17:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":316,"name":"bytes","nodeType":"ElementaryTypeName","src":"11536:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"11439:120:8"},"returnParameters":{"id":319,"nodeType":"ParameterList","parameters":[],"src":"11568:0:8"},"scope":350,"src":"11422:147:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":321,"nodeType":"StructuredDocumentation","src":"11575:1189:8","text":" @dev Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`.\n If any transfer fails, the whole call will revert.\n @param from An array of sending addresses.\n @param to An array of recipient addresses.\n @param tokenId An array of token IDs to transfer.\n @param force When set to `true`, `to` may be any address.\n When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\n @param data Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\n @custom:requirements\n - The arrays of `from`, `to` and `tokenId` must have the same length.\n - no values in the `from` array can be the zero address.\n - no values in the `to` array can be the zero address.\n - `from` and `to` cannot be the same address at the same index on each arrays.\n - each `tokenId` must be owned by `from`.\n - If the caller is not `from`, it must be an operator of each `tokenId`.\n @custom:events\n - {Transfer} events on each successful token transfer."},"functionSelector":"7e87632c","id":339,"implemented":false,"kind":"function","modifiers":[],"name":"transferBatch","nameLocation":"12778:13:8","nodeType":"FunctionDefinition","parameters":{"id":337,"nodeType":"ParameterList","parameters":[{"constant":false,"id":324,"mutability":"mutable","name":"from","nameLocation":"12818:4:8","nodeType":"VariableDeclaration","scope":339,"src":"12801:21:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_memory_ptr","typeString":"address[]"},"typeName":{"baseType":{"id":322,"name":"address","nodeType":"ElementaryTypeName","src":"12801:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":323,"nodeType":"ArrayTypeName","src":"12801:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_storage_ptr","typeString":"address[]"}},"visibility":"internal"},{"constant":false,"id":327,"mutability":"mutable","name":"to","nameLocation":"12849:2:8","nodeType":"VariableDeclaration","scope":339,"src":"12832:19:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_memory_ptr","typeString":"address[]"},"typeName":{"baseType":{"id":325,"name":"address","nodeType":"ElementaryTypeName","src":"12832:7:8","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":326,"nodeType":"ArrayTypeName","src":"12832:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_address_$dyn_storage_ptr","typeString":"address[]"}},"visibility":"internal"},{"constant":false,"id":330,"mutability":"mutable","name":"tokenId","nameLocation":"12878:7:8","nodeType":"VariableDeclaration","scope":339,"src":"12861:24:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_memory_ptr","typeString":"bytes32[]"},"typeName":{"baseType":{"id":328,"name":"bytes32","nodeType":"ElementaryTypeName","src":"12861:7:8","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"id":329,"nodeType":"ArrayTypeName","src":"12861:9:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes32_$dyn_storage_ptr","typeString":"bytes32[]"}},"visibility":"internal"},{"constant":false,"id":333,"mutability":"mutable","name":"force","nameLocation":"12909:5:8","nodeType":"VariableDeclaration","scope":339,"src":"12895:19:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_memory_ptr","typeString":"bool[]"},"typeName":{"baseType":{"id":331,"name":"bool","nodeType":"ElementaryTypeName","src":"12895:4:8","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"id":332,"nodeType":"ArrayTypeName","src":"12895:6:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bool_$dyn_storage_ptr","typeString":"bool[]"}},"visibility":"internal"},{"constant":false,"id":336,"mutability":"mutable","name":"data","nameLocation":"12939:4:8","nodeType":"VariableDeclaration","scope":339,"src":"12924:19:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":334,"name":"bytes","nodeType":"ElementaryTypeName","src":"12924:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":335,"nodeType":"ArrayTypeName","src":"12924:7:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"12791:158:8"},"returnParameters":{"id":338,"nodeType":"ParameterList","parameters":[],"src":"12958:0:8"},"scope":350,"src":"12769:190:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"documentation":{"id":340,"nodeType":"StructuredDocumentation","src":"12965:460:8","text":" @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\n @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\n @param data An array of ABI encoded function calls to be called on the contract.\n @return results An array of abi-encoded data returned by the functions executed."},"functionSelector":"6963d438","id":349,"implemented":false,"kind":"function","modifiers":[],"name":"batchCalls","nameLocation":"13439:10:8","nodeType":"FunctionDefinition","parameters":{"id":344,"nodeType":"ParameterList","parameters":[{"constant":false,"id":343,"mutability":"mutable","name":"data","nameLocation":"13476:4:8","nodeType":"VariableDeclaration","scope":349,"src":"13459:21:8","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_calldata_ptr_$dyn_calldata_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":341,"name":"bytes","nodeType":"ElementaryTypeName","src":"13459:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":342,"nodeType":"ArrayTypeName","src":"13459:7:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"13449:37:8"},"returnParameters":{"id":348,"nodeType":"ParameterList","parameters":[{"constant":false,"id":347,"mutability":"mutable","name":"results","nameLocation":"13520:7:8","nodeType":"VariableDeclaration","scope":349,"src":"13505:22:8","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_memory_ptr_$dyn_memory_ptr","typeString":"bytes[]"},"typeName":{"baseType":{"id":345,"name":"bytes","nodeType":"ElementaryTypeName","src":"13505:5:8","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"id":346,"nodeType":"ArrayTypeName","src":"13505:7:8","typeDescriptions":{"typeIdentifier":"t_array$_t_bytes_storage_$dyn_storage_ptr","typeString":"bytes[]"}},"visibility":"internal"}],"src":"13504:24:8"},"scope":350,"src":"13430:99:8","stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"scope":351,"src":"359:13172:8","usedErrors":[],"usedEvents":[13,155,166,179,188]}],"src":"39:13493:8"},"id":8},"@openzeppelin/contracts/utils/introspection/ERC165.sol":{"ast":{"absolutePath":"@openzeppelin/contracts/utils/introspection/ERC165.sol","exportedSymbols":{"ERC165":[374],"IERC165":[386]},"id":375,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":352,"literals":["solidity","^","0.8",".20"],"nodeType":"PragmaDirective","src":"114:24:9"},{"absolutePath":"@openzeppelin/contracts/utils/introspection/IERC165.sol","file":"./IERC165.sol","id":354,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":375,"sourceUnit":387,"src":"140:38:9","symbolAliases":[{"foreign":{"id":353,"name":"IERC165","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":386,"src":"148:7:9","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"abstract":true,"baseContracts":[{"baseName":{"id":356,"name":"IERC165","nameLocations":["687:7:9"],"nodeType":"IdentifierPath","referencedDeclaration":386,"src":"687:7:9"},"id":357,"nodeType":"InheritanceSpecifier","src":"687:7:9"}],"canonicalName":"ERC165","contractDependencies":[],"contractKind":"contract","documentation":{"id":355,"nodeType":"StructuredDocumentation","src":"180:478:9","text":" @dev Implementation of the {IERC165} interface.\n Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n for the additional interface id that will be supported. For example:\n ```solidity\n function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n }\n ```"},"fullyImplemented":true,"id":374,"linearizedBaseContracts":[374,386],"name":"ERC165","nameLocation":"677:6:9","nodeType":"ContractDefinition","nodes":[{"baseFunctions":[385],"body":{"id":372,"nodeType":"Block","src":"844:64:9","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"id":370,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":365,"name":"interfaceId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":360,"src":"861:11:9","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"expression":{"arguments":[{"id":367,"name":"IERC165","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":386,"src":"881:7:9","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IERC165_$386_$","typeString":"type(contract IERC165)"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_type$_t_contract$_IERC165_$386_$","typeString":"type(contract IERC165)"}],"id":366,"name":"type","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-27,"src":"876:4:9","typeDescriptions":{"typeIdentifier":"t_function_metatype_pure$__$returns$__$","typeString":"function () pure"}},"id":368,"isConstant":false,"isLValue":false,"isPure":true,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"876:13:9","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_magic_meta_type_t_contract$_IERC165_$386","typeString":"type(contract IERC165)"}},"id":369,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"memberLocation":"890:11:9","memberName":"interfaceId","nodeType":"MemberAccess","src":"876:25:9","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"src":"861:40:9","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":364,"id":371,"nodeType":"Return","src":"854:47:9"}]},"documentation":{"id":358,"nodeType":"StructuredDocumentation","src":"701:56:9","text":" @dev See {IERC165-supportsInterface}."},"functionSelector":"01ffc9a7","id":373,"implemented":true,"kind":"function","modifiers":[],"name":"supportsInterface","nameLocation":"771:17:9","nodeType":"FunctionDefinition","parameters":{"id":361,"nodeType":"ParameterList","parameters":[{"constant":false,"id":360,"mutability":"mutable","name":"interfaceId","nameLocation":"796:11:9","nodeType":"VariableDeclaration","scope":373,"src":"789:18:9","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":359,"name":"bytes4","nodeType":"ElementaryTypeName","src":"789:6:9","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"visibility":"internal"}],"src":"788:20:9"},"returnParameters":{"id":364,"nodeType":"ParameterList","parameters":[{"constant":false,"id":363,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":373,"src":"838:4:9","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":362,"name":"bool","nodeType":"ElementaryTypeName","src":"838:4:9","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"837:6:9"},"scope":374,"src":"762:146:9","stateMutability":"view","virtual":true,"visibility":"public"}],"scope":375,"src":"659:251:9","usedErrors":[],"usedEvents":[]}],"src":"114:797:9"},"id":9},"@openzeppelin/contracts/utils/introspection/IERC165.sol":{"ast":{"absolutePath":"@openzeppelin/contracts/utils/introspection/IERC165.sol","exportedSymbols":{"IERC165":[386]},"id":387,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":376,"literals":["solidity","^","0.8",".20"],"nodeType":"PragmaDirective","src":"115:24:10"},{"abstract":false,"baseContracts":[],"canonicalName":"IERC165","contractDependencies":[],"contractKind":"interface","documentation":{"id":377,"nodeType":"StructuredDocumentation","src":"141:279:10","text":" @dev Interface of the ERC165 standard, as defined in the\n https://eips.ethereum.org/EIPS/eip-165[EIP].\n Implementers can declare support of contract interfaces, which can then be\n queried by others ({ERC165Checker}).\n For an implementation, see {ERC165}."},"fullyImplemented":false,"id":386,"linearizedBaseContracts":[386],"name":"IERC165","nameLocation":"431:7:10","nodeType":"ContractDefinition","nodes":[{"documentation":{"id":378,"nodeType":"StructuredDocumentation","src":"445:340:10","text":" @dev Returns true if this contract implements the interface defined by\n `interfaceId`. See the corresponding\n https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n to learn more about how these ids are created.\n This function call must use less than 30 000 gas."},"functionSelector":"01ffc9a7","id":385,"implemented":false,"kind":"function","modifiers":[],"name":"supportsInterface","nameLocation":"799:17:10","nodeType":"FunctionDefinition","parameters":{"id":381,"nodeType":"ParameterList","parameters":[{"constant":false,"id":380,"mutability":"mutable","name":"interfaceId","nameLocation":"824:11:10","nodeType":"VariableDeclaration","scope":385,"src":"817:18:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":379,"name":"bytes4","nodeType":"ElementaryTypeName","src":"817:6:10","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"visibility":"internal"}],"src":"816:20:10"},"returnParameters":{"id":384,"nodeType":"ParameterList","parameters":[{"constant":false,"id":383,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":385,"src":"860:4:10","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":382,"name":"bool","nodeType":"ElementaryTypeName","src":"860:4:10","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"859:6:10"},"scope":386,"src":"790:76:10","stateMutability":"view","virtual":false,"visibility":"external"}],"scope":387,"src":"421:447:10","usedErrors":[],"usedEvents":[]}],"src":"115:754:10"},"id":10},"contracts/interfaces/IShirts.sol":{"ast":{"absolutePath":"contracts/interfaces/IShirts.sol","exportedSymbols":{"ILSP8":[350],"IShirts":[416]},"id":417,"license":"MIT","nodeType":"SourceUnit","nodes":[{"id":388,"literals":["solidity","0.8",".20"],"nodeType":"PragmaDirective","src":"32:23:11"},{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol","file":"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol","id":390,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":417,"sourceUnit":63,"src":"57:155:11","symbolAliases":[{"foreign":{"id":389,"name":"ILSP8IdentifiableDigitalAsset","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":350,"src":"65:29:11","typeDescriptions":{}},"local":"ILSP8","nameLocation":"-1:-1:-1"}],"unitAlias":""},{"abstract":false,"baseContracts":[{"baseName":{"id":391,"name":"ILSP8","nameLocations":["234:5:11"],"nodeType":"IdentifierPath","referencedDeclaration":350,"src":"234:5:11"},"id":392,"nodeType":"InheritanceSpecifier","src":"234:5:11"}],"canonicalName":"IShirts","contractDependencies":[],"contractKind":"interface","fullyImplemented":false,"id":416,"linearizedBaseContracts":[416,350,50,386],"name":"IShirts","nameLocation":"223:7:11","nodeType":"ContractDefinition","nodes":[{"anonymous":false,"eventSelector":"2d6f147bcef20580d606c930254442a27952b0caec97caaba61b00b5dd67bba9","id":398,"name":"ShirtsMinted","nameLocation":"252:12:11","nodeType":"EventDefinition","parameters":{"id":397,"nodeType":"ParameterList","parameters":[{"constant":false,"id":394,"indexed":false,"mutability":"mutable","name":"_recipient","nameLocation":"273:10:11","nodeType":"VariableDeclaration","scope":398,"src":"265:18:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":393,"name":"address","nodeType":"ElementaryTypeName","src":"265:7:11","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":396,"indexed":false,"mutability":"mutable","name":"_amount","nameLocation":"293:7:11","nodeType":"VariableDeclaration","scope":398,"src":"285:15:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":395,"name":"uint256","nodeType":"ElementaryTypeName","src":"285:7:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"264:37:11"},"src":"246:56:11"},{"functionSelector":"40c10f19","id":405,"implemented":false,"kind":"function","modifiers":[],"name":"mint","nameLocation":"317:4:11","nodeType":"FunctionDefinition","parameters":{"id":403,"nodeType":"ParameterList","parameters":[{"constant":false,"id":400,"mutability":"mutable","name":"_recipient","nameLocation":"339:10:11","nodeType":"VariableDeclaration","scope":405,"src":"331:18:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":399,"name":"address","nodeType":"ElementaryTypeName","src":"331:7:11","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":402,"mutability":"mutable","name":"_amount","nameLocation":"367:7:11","nodeType":"VariableDeclaration","scope":405,"src":"359:15:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":401,"name":"uint256","nodeType":"ElementaryTypeName","src":"359:7:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"321:59:11"},"returnParameters":{"id":404,"nodeType":"ParameterList","parameters":[],"src":"397:0:11"},"scope":416,"src":"308:90:11","stateMutability":"payable","virtual":false,"visibility":"external"},{"functionSelector":"884bf67c","id":410,"implemented":false,"kind":"function","modifiers":[],"name":"getPrizePool","nameLocation":"417:12:11","nodeType":"FunctionDefinition","parameters":{"id":406,"nodeType":"ParameterList","parameters":[],"src":"429:2:11"},"returnParameters":{"id":409,"nodeType":"ParameterList","parameters":[{"constant":false,"id":408,"mutability":"mutable","name":"prizePool","nameLocation":"463:9:11","nodeType":"VariableDeclaration","scope":410,"src":"455:17:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":407,"name":"address","nodeType":"ElementaryTypeName","src":"455:7:11","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"454:19:11"},"scope":416,"src":"408:66:11","stateMutability":"view","virtual":false,"visibility":"external"},{"functionSelector":"98d5fdca","id":415,"implemented":false,"kind":"function","modifiers":[],"name":"getPrice","nameLocation":"489:8:11","nodeType":"FunctionDefinition","parameters":{"id":411,"nodeType":"ParameterList","parameters":[],"src":"497:2:11"},"returnParameters":{"id":414,"nodeType":"ParameterList","parameters":[{"constant":false,"id":413,"mutability":"mutable","name":"price","nameLocation":"531:5:11","nodeType":"VariableDeclaration","scope":415,"src":"523:13:11","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":412,"name":"uint256","nodeType":"ElementaryTypeName","src":"523:7:11","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"522:15:11"},"scope":416,"src":"480:58:11","stateMutability":"view","virtual":false,"visibility":"external"}],"scope":417,"src":"213:327:11","usedErrors":[],"usedEvents":[13,155,166,179,188,398]}],"src":"32:508:11"},"id":11},"contracts/mocks/UPMock.sol":{"ast":{"absolutePath":"contracts/mocks/UPMock.sol","exportedSymbols":{"BPunX":[434],"ERC165":[374],"ILSP1UniversalReceiver":[115],"IShirts":[416],"UPMock":[549],"_INTERFACEID_LSP0":[67],"_INTERFACEID_LSP1":[120]},"id":550,"license":"Apache-2.0","nodeType":"SourceUnit","nodes":[{"id":418,"literals":["solidity","^","0.8",".4"],"nodeType":"PragmaDirective","src":"39:23:12"},{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol","file":"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol","id":420,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":550,"sourceUnit":57,"src":"78:131:12","symbolAliases":[{"foreign":{"id":419,"name":"ILSP1UniversalReceiver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":115,"src":"91:22:12","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"absolutePath":"@openzeppelin/contracts/utils/introspection/ERC165.sol","file":"@openzeppelin/contracts/utils/introspection/ERC165.sol","id":422,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":550,"sourceUnit":375,"src":"222:84:12","symbolAliases":[{"foreign":{"id":421,"name":"ERC165","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":374,"src":"235:6:12","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol","file":"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol","id":424,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":550,"sourceUnit":60,"src":"321:111:12","symbolAliases":[{"foreign":{"id":423,"name":"_INTERFACEID_LSP1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":120,"src":"329:17:12","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"absolutePath":"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol","file":"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol","id":426,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":550,"sourceUnit":54,"src":"433:107:12","symbolAliases":[{"foreign":{"id":425,"name":"_INTERFACEID_LSP0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":67,"src":"441:17:12","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"absolutePath":"contracts/interfaces/IShirts.sol","file":"../interfaces/IShirts.sol","id":428,"nameLocation":"-1:-1:-1","nodeType":"ImportDirective","scope":550,"sourceUnit":417,"src":"542:50:12","symbolAliases":[{"foreign":{"id":427,"name":"IShirts","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":416,"src":"550:7:12","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"abstract":false,"baseContracts":[],"canonicalName":"BPunX","contractDependencies":[],"contractKind":"interface","fullyImplemented":false,"id":434,"linearizedBaseContracts":[434],"name":"BPunX","nameLocation":"604:5:12","nodeType":"ContractDefinition","nodes":[{"functionSelector":"a0712d68","id":433,"implemented":false,"kind":"function","modifiers":[],"name":"mint","nameLocation":"625:4:12","nodeType":"FunctionDefinition","parameters":{"id":431,"nodeType":"ParameterList","parameters":[{"constant":false,"id":430,"mutability":"mutable","name":"_amount","nameLocation":"638:7:12","nodeType":"VariableDeclaration","scope":433,"src":"630:15:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":429,"name":"uint256","nodeType":"ElementaryTypeName","src":"630:7:12","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"629:17:12"},"returnParameters":{"id":432,"nodeType":"ParameterList","parameters":[],"src":"663:0:12"},"scope":434,"src":"616:48:12","stateMutability":"payable","virtual":false,"visibility":"external"}],"scope":550,"src":"594:72:12","usedErrors":[],"usedEvents":[]},{"abstract":false,"baseContracts":[{"baseName":{"id":435,"name":"ERC165","nameLocations":["686:6:12"],"nodeType":"IdentifierPath","referencedDeclaration":374,"src":"686:6:12"},"id":436,"nodeType":"InheritanceSpecifier","src":"686:6:12"},{"baseName":{"id":437,"name":"ILSP1UniversalReceiver","nameLocations":["694:22:12"],"nodeType":"IdentifierPath","referencedDeclaration":115,"src":"694:22:12"},"id":438,"nodeType":"InheritanceSpecifier","src":"694:22:12"}],"canonicalName":"UPMock","contractDependencies":[],"contractKind":"contract","fullyImplemented":true,"id":549,"linearizedBaseContracts":[549,115,374,386],"name":"UPMock","nameLocation":"676:6:12","nodeType":"ContractDefinition","nodes":[{"baseFunctions":[373],"body":{"id":460,"nodeType":"Block","src":"923:168:12","statements":[{"expression":{"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":458,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_bool","typeString":"bool"},"id":453,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"commonType":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"id":449,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":447,"name":"interfaceId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":441,"src":"952:11:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":448,"name":"_INTERFACEID_LSP1","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":120,"src":"967:17:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"src":"952:32:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"commonType":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"id":452,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"leftExpression":{"id":450,"name":"interfaceId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":441,"src":"1000:11:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"nodeType":"BinaryOperation","operator":"==","rightExpression":{"id":451,"name":"_INTERFACEID_LSP0","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":67,"src":"1015:17:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"src":"1000:32:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"952:80:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"nodeType":"BinaryOperation","operator":"||","rightExpression":{"arguments":[{"id":456,"name":"interfaceId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":441,"src":"1072:11:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_bytes4","typeString":"bytes4"}],"expression":{"id":454,"name":"super","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-25,"src":"1048:5:12","typeDescriptions":{"typeIdentifier":"t_type$_t_super$_UPMock_$549_$","typeString":"type(contract super UPMock)"}},"id":455,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1054:17:12","memberName":"supportsInterface","nodeType":"MemberAccess","referencedDeclaration":373,"src":"1048:23:12","typeDescriptions":{"typeIdentifier":"t_function_internal_view$_t_bytes4_$returns$_t_bool_$","typeString":"function (bytes4) view returns (bool)"}},"id":457,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1048:36:12","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"src":"952:132:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"functionReturnParameters":446,"id":459,"nodeType":"Return","src":"933:151:12"}]},"documentation":{"id":439,"nodeType":"StructuredDocumentation","src":"728:55:12","text":"override the supportsInterface function from ERC165"},"functionSelector":"01ffc9a7","id":461,"implemented":true,"kind":"function","modifiers":[],"name":"supportsInterface","nameLocation":"797:17:12","nodeType":"FunctionDefinition","overrides":{"id":443,"nodeType":"OverrideSpecifier","overrides":[],"src":"887:8:12"},"parameters":{"id":442,"nodeType":"ParameterList","parameters":[{"constant":false,"id":441,"mutability":"mutable","name":"interfaceId","nameLocation":"822:11:12","nodeType":"VariableDeclaration","scope":461,"src":"815:18:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":440,"name":"bytes4","nodeType":"ElementaryTypeName","src":"815:6:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"visibility":"internal"}],"src":"814:20:12"},"returnParameters":{"id":446,"nodeType":"ParameterList","parameters":[{"constant":false,"id":445,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":461,"src":"913:4:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":444,"name":"bool","nodeType":"ElementaryTypeName","src":"913:4:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"912:6:12"},"scope":549,"src":"788:303:12","stateMutability":"view","virtual":true,"visibility":"public"},{"baseFunctions":[114],"body":{"id":483,"nodeType":"Block","src":"1241:118:12","statements":[{"eventCall":{"arguments":[{"expression":{"id":472,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1274:3:12","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":473,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1278:6:12","memberName":"sender","nodeType":"MemberAccess","src":"1274:10:12","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"expression":{"id":474,"name":"msg","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-15,"src":"1286:3:12","typeDescriptions":{"typeIdentifier":"t_magic_message","typeString":"msg"}},"id":475,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1290:5:12","memberName":"value","nodeType":"MemberAccess","src":"1286:9:12","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},{"id":476,"name":"typeId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":463,"src":"1297:6:12","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":477,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":465,"src":"1305:4:12","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}},{"hexValue":"","id":478,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"1311:2:12","typeDescriptions":{"typeIdentifier":"t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470","typeString":"literal_string \"\""},"value":""}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_uint256","typeString":"uint256"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"},{"typeIdentifier":"t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470","typeString":"literal_string \"\""}],"id":471,"name":"UniversalReceiver","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":104,"src":"1256:17:12","typeDescriptions":{"typeIdentifier":"t_function_event_nonpayable$_t_address_$_t_uint256_$_t_bytes32_$_t_bytes_memory_ptr_$_t_bytes_memory_ptr_$returns$__$","typeString":"function (address,uint256,bytes32,bytes memory,bytes memory)"}},"id":479,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1256:58:12","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":480,"nodeType":"EmitStatement","src":"1251:63:12"},{"expression":{"hexValue":"7468616e6b7320666f722063616c6c696e67","id":481,"isConstant":false,"isLValue":false,"isPure":true,"kind":"string","lValueRequested":false,"nodeType":"Literal","src":"1332:20:12","typeDescriptions":{"typeIdentifier":"t_stringliteral_dfc0b1f2319a6b0c540ddfadad59620bc50281e920ba4015ed9a098c0a4325a3","typeString":"literal_string \"thanks for calling\""},"value":"thanks for calling"},"functionReturnParameters":470,"id":482,"nodeType":"Return","src":"1325:27:12"}]},"functionSelector":"6bb56a14","id":484,"implemented":true,"kind":"function","modifiers":[],"name":"universalReceiver","nameLocation":"1105:17:12","nodeType":"FunctionDefinition","overrides":{"id":467,"nodeType":"OverrideSpecifier","overrides":[],"src":"1197:8:12"},"parameters":{"id":466,"nodeType":"ParameterList","parameters":[{"constant":false,"id":463,"mutability":"mutable","name":"typeId","nameLocation":"1140:6:12","nodeType":"VariableDeclaration","scope":484,"src":"1132:14:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":462,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1132:7:12","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":465,"mutability":"mutable","name":"data","nameLocation":"1169:4:12","nodeType":"VariableDeclaration","scope":484,"src":"1156:17:12","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":464,"name":"bytes","nodeType":"ElementaryTypeName","src":"1156:5:12","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1122:57:12"},"returnParameters":{"id":470,"nodeType":"ParameterList","parameters":[{"constant":false,"id":469,"mutability":"mutable","name":"returnValue","nameLocation":"1228:11:12","nodeType":"VariableDeclaration","scope":484,"src":"1215:24:12","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":468,"name":"bytes","nodeType":"ElementaryTypeName","src":"1215:5:12","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1214:26:12"},"scope":549,"src":"1096:263:12","stateMutability":"payable","virtual":false,"visibility":"external"},{"body":{"id":496,"nodeType":"Block","src":"1596:83:12","statements":[{"expression":{"hexValue":"30783136323662613765","id":494,"isConstant":false,"isLValue":false,"isPure":true,"kind":"number","lValueRequested":false,"nodeType":"Literal","src":"1662:10:12","typeDescriptions":{"typeIdentifier":"t_rational_371636862_by_1","typeString":"int_const 371636862"},"value":"0x1626ba7e"},"functionReturnParameters":493,"id":495,"nodeType":"Return","src":"1655:17:12"}]},"documentation":{"id":485,"nodeType":"StructuredDocumentation","src":"1364:89:12","text":" @notice Verifies that the signer is the owner of the signing contract."},"functionSelector":"1626ba7e","id":497,"implemented":true,"kind":"function","modifiers":[],"name":"isValidSignature","nameLocation":"1467:16:12","nodeType":"FunctionDefinition","parameters":{"id":490,"nodeType":"ParameterList","parameters":[{"constant":false,"id":487,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":497,"src":"1493:7:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":486,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1493:7:12","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":489,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":497,"src":"1528:14:12","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes"},"typeName":{"id":488,"name":"bytes","nodeType":"ElementaryTypeName","src":"1528:5:12","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1483:81:12"},"returnParameters":{"id":493,"nodeType":"ParameterList","parameters":[{"constant":false,"id":492,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":497,"src":"1588:6:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"},"typeName":{"id":491,"name":"bytes4","nodeType":"ElementaryTypeName","src":"1588:6:12","typeDescriptions":{"typeIdentifier":"t_bytes4","typeString":"bytes4"}},"visibility":"internal"}],"src":"1587:8:12"},"scope":549,"src":"1458:221:12","stateMutability":"pure","virtual":false,"visibility":"external"},{"body":{"id":523,"nodeType":"Block","src":"1855:73:12","statements":[{"expression":{"arguments":[{"id":516,"name":"from","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":501,"src":"1890:4:12","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":517,"name":"to","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":503,"src":"1896:2:12","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},{"id":518,"name":"tokenId","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":505,"src":"1900:7:12","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},{"id":519,"name":"force","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":507,"src":"1909:5:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},{"id":520,"name":"data","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":509,"src":"1916:4:12","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_address","typeString":"address"},{"typeIdentifier":"t_bytes32","typeString":"bytes32"},{"typeIdentifier":"t_bool","typeString":"bool"},{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes memory"}],"expression":{"arguments":[{"id":513,"name":"shirts","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":499,"src":"1873:6:12","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_address","typeString":"address"}],"id":512,"name":"IShirts","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":416,"src":"1865:7:12","typeDescriptions":{"typeIdentifier":"t_type$_t_contract$_IShirts_$416_$","typeString":"type(contract IShirts)"}},"id":514,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1865:15:12","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_contract$_IShirts_$416","typeString":"contract IShirts"}},"id":515,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"1881:8:12","memberName":"transfer","nodeType":"MemberAccess","referencedDeclaration":320,"src":"1865:24:12","typeDescriptions":{"typeIdentifier":"t_function_external_nonpayable$_t_address_$_t_address_$_t_bytes32_$_t_bool_$_t_bytes_memory_ptr_$returns$__$","typeString":"function (address,address,bytes32,bool,bytes memory) external"}},"id":521,"isConstant":false,"isLValue":false,"isPure":false,"kind":"functionCall","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"1865:56:12","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_tuple$__$","typeString":"tuple()"}},"id":522,"nodeType":"ExpressionStatement","src":"1865:56:12"}]},"functionSelector":"876e93fe","id":524,"implemented":true,"kind":"function","modifiers":[],"name":"transfer","nameLocation":"1693:8:12","nodeType":"FunctionDefinition","parameters":{"id":510,"nodeType":"ParameterList","parameters":[{"constant":false,"id":499,"mutability":"mutable","name":"shirts","nameLocation":"1719:6:12","nodeType":"VariableDeclaration","scope":524,"src":"1711:14:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":498,"name":"address","nodeType":"ElementaryTypeName","src":"1711:7:12","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":501,"mutability":"mutable","name":"from","nameLocation":"1743:4:12","nodeType":"VariableDeclaration","scope":524,"src":"1735:12:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":500,"name":"address","nodeType":"ElementaryTypeName","src":"1735:7:12","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":503,"mutability":"mutable","name":"to","nameLocation":"1765:2:12","nodeType":"VariableDeclaration","scope":524,"src":"1757:10:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":502,"name":"address","nodeType":"ElementaryTypeName","src":"1757:7:12","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":505,"mutability":"mutable","name":"tokenId","nameLocation":"1785:7:12","nodeType":"VariableDeclaration","scope":524,"src":"1777:15:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"},"typeName":{"id":504,"name":"bytes32","nodeType":"ElementaryTypeName","src":"1777:7:12","typeDescriptions":{"typeIdentifier":"t_bytes32","typeString":"bytes32"}},"visibility":"internal"},{"constant":false,"id":507,"mutability":"mutable","name":"force","nameLocation":"1807:5:12","nodeType":"VariableDeclaration","scope":524,"src":"1802:10:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":506,"name":"bool","nodeType":"ElementaryTypeName","src":"1802:4:12","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":509,"mutability":"mutable","name":"data","nameLocation":"1835:4:12","nodeType":"VariableDeclaration","scope":524,"src":"1822:17:12","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":508,"name":"bytes","nodeType":"ElementaryTypeName","src":"1822:5:12","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1701:144:12"},"returnParameters":{"id":511,"nodeType":"ParameterList","parameters":[],"src":"1855:0:12"},"scope":549,"src":"1684:244:12","stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"body":{"id":527,"nodeType":"Block","src":"1966:2:12","statements":[]},"functionSelector":"b60d4288","id":528,"implemented":true,"kind":"function","modifiers":[],"name":"fund","nameLocation":"1942:4:12","nodeType":"FunctionDefinition","parameters":{"id":525,"nodeType":"ParameterList","parameters":[],"src":"1946:2:12"},"returnParameters":{"id":526,"nodeType":"ParameterList","parameters":[],"src":"1966:0:12"},"scope":549,"src":"1933:35:12","stateMutability":"payable","virtual":false,"visibility":"external"},{"body":{"id":539,"nodeType":"Block","src":"2027:45:12","statements":[{"expression":{"expression":{"arguments":[{"id":535,"name":"this","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":-28,"src":"2052:4:12","typeDescriptions":{"typeIdentifier":"t_contract$_UPMock_$549","typeString":"contract UPMock"}}],"expression":{"argumentTypes":[{"typeIdentifier":"t_contract$_UPMock_$549","typeString":"contract UPMock"}],"id":534,"isConstant":false,"isLValue":false,"isPure":true,"lValueRequested":false,"nodeType":"ElementaryTypeNameExpression","src":"2044:7:12","typeDescriptions":{"typeIdentifier":"t_type$_t_address_$","typeString":"type(address)"},"typeName":{"id":533,"name":"address","nodeType":"ElementaryTypeName","src":"2044:7:12","typeDescriptions":{}}},"id":536,"isConstant":false,"isLValue":false,"isPure":false,"kind":"typeConversion","lValueRequested":false,"nameLocations":[],"names":[],"nodeType":"FunctionCall","src":"2044:13:12","tryCall":false,"typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"id":537,"isConstant":false,"isLValue":false,"isPure":false,"lValueRequested":false,"memberLocation":"2058:7:12","memberName":"balance","nodeType":"MemberAccess","src":"2044:21:12","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"functionReturnParameters":532,"id":538,"nodeType":"Return","src":"2037:28:12"}]},"functionSelector":"12065fe0","id":540,"implemented":true,"kind":"function","modifiers":[],"name":"getBalance","nameLocation":"1982:10:12","nodeType":"FunctionDefinition","parameters":{"id":529,"nodeType":"ParameterList","parameters":[],"src":"1992:2:12"},"returnParameters":{"id":532,"nodeType":"ParameterList","parameters":[{"constant":false,"id":531,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":540,"src":"2018:7:12","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":530,"name":"uint256","nodeType":"ElementaryTypeName","src":"2018:7:12","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2017:9:12"},"scope":549,"src":"1973:99:12","stateMutability":"view","virtual":false,"visibility":"external"},{"body":{"id":543,"nodeType":"Block","src":"2104:2:12","statements":[]},"id":544,"implemented":true,"kind":"receive","modifiers":[],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":541,"nodeType":"ParameterList","parameters":[],"src":"2084:2:12"},"returnParameters":{"id":542,"nodeType":"ParameterList","parameters":[],"src":"2104:0:12"},"scope":549,"src":"2077:29:12","stateMutability":"payable","virtual":false,"visibility":"external"},{"body":{"id":547,"nodeType":"Block","src":"2139:2:12","statements":[]},"id":548,"implemented":true,"kind":"fallback","modifiers":[],"name":"","nameLocation":"-1:-1:-1","nodeType":"FunctionDefinition","parameters":{"id":545,"nodeType":"ParameterList","parameters":[],"src":"2119:2:12"},"returnParameters":{"id":546,"nodeType":"ParameterList","parameters":[],"src":"2139:0:12"},"scope":549,"src":"2111:30:12","stateMutability":"payable","virtual":false,"visibility":"external"}],"scope":550,"src":"667:1476:12","usedErrors":[],"usedEvents":[104]}],"src":"39:2104:12"},"id":12}},"contracts":{"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol":{"IERC725Y":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"DataChanged","type":"event"},{"inputs":[{"internalType":"bytes32","name":"dataKey","type":"bytes32"}],"name":"getData","outputs":[{"internalType":"bytes","name":"dataValue","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"}],"name":"getDataBatch","outputs":[{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"setData","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"},{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"name":"setDataBatch","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"devdoc":{"details":"ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time. It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.","events":{"DataChanged(bytes32,bytes)":{"details":"Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.","params":{"dataKey":"The data key for which a bytes value is set.","dataValue":"The value to set for the given data key."}}},"kind":"dev","methods":{"getData(bytes32)":{"details":"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.","params":{"dataKey":"The data key for which to retrieve the value."},"returns":{"dataValue":"The bytes value stored under the specified data key."}},"getDataBatch(bytes32[])":{"details":"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.","params":{"dataKeys":"The array of keys which values to retrieve"},"returns":{"dataValues":"The array of data stored at multiple keys"}},"setData(bytes32,bytes)":{"details":"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.","params":{"dataKey":"The data key for which to set a new value.","dataValue":"The new bytes value to set."}},"setDataBatch(bytes32[],bytes[])":{"details":"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.","params":{"dataKeys":"An array of data keys to set bytes values for.","dataValues":"An array of bytes values to set for each `dataKeys`."}},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}},"title":"The interface for ERC725Y sub-standard, a generic data key/value store.","version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"getData(bytes32)":"54f6127f","getDataBatch(bytes32[])":"dedff9c6","setData(bytes32,bytes)":"7f23690c","setDataBatch(bytes32[],bytes[])":"97902421","supportsInterface(bytes4)":"01ffc9a7"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"DataChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getDataBatch\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"setData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"name\":\"setDataBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time. It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\",\"events\":{\"DataChanged(bytes32,bytes)\":{\"details\":\"Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\",\"params\":{\"dataKey\":\"The data key for which a bytes value is set.\",\"dataValue\":\"The value to set for the given data key.\"}}},\"kind\":\"dev\",\"methods\":{\"getData(bytes32)\":{\"details\":\"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\",\"params\":{\"dataKey\":\"The data key for which to retrieve the value.\"},\"returns\":{\"dataValue\":\"The bytes value stored under the specified data key.\"}},\"getDataBatch(bytes32[])\":{\"details\":\"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\",\"params\":{\"dataKeys\":\"The array of keys which values to retrieve\"},\"returns\":{\"dataValues\":\"The array of data stored at multiple keys\"}},\"setData(bytes32,bytes)\":{\"details\":\"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.\",\"params\":{\"dataKey\":\"The data key for which to set a new value.\",\"dataValue\":\"The new bytes value to set.\"}},\"setDataBatch(bytes32[],bytes[])\":{\"details\":\"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\",\"params\":{\"dataKeys\":\"An array of data keys to set bytes values for.\",\"dataValues\":\"An array of bytes values to set for each `dataKeys`.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"title\":\"The interface for ERC725Y sub-standard, a generic data key/value store.\",\"version\":1},\"userdoc\":{\"events\":{\"DataChanged(bytes32,bytes)\":{\"notice\":\"The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\"}},\"kind\":\"user\",\"methods\":{\"getData(bytes32)\":{\"notice\":\"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\"},\"getDataBatch(bytes32[])\":{\"notice\":\"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\"},\"setData(bytes32,bytes)\":{\"notice\":\"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\"},\"setDataBatch(bytes32[],bytes[])\":{\"notice\":\"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\":\"IERC725Y\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\\n */\\ninterface IERC725Y is IERC165 {\\n    /**\\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\\n     * @param dataKey The data key for which to retrieve the value.\\n     * @return dataValue The bytes value stored under the specified data key.\\n     */\\n    function getData(\\n        bytes32 dataKey\\n    ) external view returns (bytes memory dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\\n     * @param dataKeys The array of keys which values to retrieve\\n     * @return dataValues The array of data stored at multiple keys\\n     */\\n    function getDataBatch(\\n        bytes32[] memory dataKeys\\n    ) external view returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\\n     *\\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\\n     * a fee mechanism for setting specific data.\\n     *\\n     * @param dataKey The data key for which to set a new value.\\n     * @param dataValue The new bytes value to set.\\n     */\\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\\n\\n    /**\\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\\n     *\\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\\n     *\\n     * @param dataKeys An array of data keys to set bytes values for.\\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\\n     */\\n    function setDataBatch(\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xa47c9e3eba0c733a1685b9fa309f753540c89ad2dca73236a2c953e7f5680e7b\",\"license\":\"CC0-1.0\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"events":{"DataChanged(bytes32,bytes)":{"notice":"The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`."}},"kind":"user","methods":{"getData(bytes32)":{"notice":"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."},"getDataBatch(bytes32[])":{"notice":"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."},"setData(bytes32,bytes)":{"notice":"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."},"setDataBatch(bytes32[],bytes[])":{"notice":"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."}},"version":1}}},"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol":{"ILSP1UniversalReceiver":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"uint256","name":"value","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"typeId","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"receivedData","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"returnedValue","type":"bytes"}],"name":"UniversalReceiver","type":"event"},{"inputs":[{"internalType":"bytes32","name":"typeId","type":"bytes32"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"universalReceiver","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"payable","type":"function"}],"devdoc":{"details":"LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received.","events":{"UniversalReceiver(address,uint256,bytes32,bytes,bytes)":{"details":"Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`","params":{"from":"The address of the EOA or smart contract that called the {universalReceiver(...)} function.","receivedData":"Any arbitrary data that was sent to the {universalReceiver(...)} function.","returnedValue":"The value returned by the {universalReceiver(...)} function.","typeId":"A `bytes32` unique identifier (= _\"hook\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.","value":"The amount sent to the {universalReceiver(...)} function."}}},"kind":"dev","methods":{"universalReceiver(bytes32,bytes)":{"custom:events":"{UniversalReceiver} event.","details":"Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.","params":{"data":"The arbitrary data received with the call.","typeId":"The hash of a specific standard or a hook."}}},"title":"Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.","version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"universalReceiver(bytes32,bytes)":"6bb56a14"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"typeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"receivedData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnedValue\",\"type\":\"bytes\"}],\"name\":\"UniversalReceiver\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"typeId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"universalReceiver\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received.\",\"events\":{\"UniversalReceiver(address,uint256,bytes32,bytes,bytes)\":{\"details\":\"Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\",\"params\":{\"from\":\"The address of the EOA or smart contract that called the {universalReceiver(...)} function.\",\"receivedData\":\"Any arbitrary data that was sent to the {universalReceiver(...)} function.\",\"returnedValue\":\"The value returned by the {universalReceiver(...)} function.\",\"typeId\":\"A `bytes32` unique identifier (= _\\\"hook\\\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\",\"value\":\"The amount sent to the {universalReceiver(...)} function.\"}}},\"kind\":\"dev\",\"methods\":{\"universalReceiver(bytes32,bytes)\":{\"custom:events\":\"{UniversalReceiver} event.\",\"details\":\"Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\",\"params\":{\"data\":\"The arbitrary data received with the call.\",\"typeId\":\"The hash of a specific standard or a hook.\"}}},\"title\":\"Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.\",\"version\":1},\"userdoc\":{\"events\":{\"UniversalReceiver(address,uint256,bytes32,bytes,bytes)\":{\"notice\":\"Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\"}},\"kind\":\"user\",\"methods\":{\"universalReceiver(bytes32,bytes)\":{\"notice\":\"Reacted on received notification with `typeId` & `data`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\":\"ILSP1UniversalReceiver\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.\\n * @dev LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received.\\n */\\ninterface ILSP1UniversalReceiver {\\n    /**\\n     * @dev Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\\n     * @notice Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\\n     *\\n     * @param from The address of the EOA or smart contract that called the {universalReceiver(...)} function.\\n     * @param value The amount sent to the {universalReceiver(...)} function.\\n     * @param typeId A `bytes32` unique identifier (= _\\\"hook\\\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\\n     * @param receivedData Any arbitrary data that was sent to the {universalReceiver(...)} function.\\n     * @param returnedValue The value returned by the {universalReceiver(...)} function.\\n     */\\n    event UniversalReceiver(\\n        address indexed from,\\n        uint256 indexed value,\\n        bytes32 indexed typeId,\\n        bytes receivedData,\\n        bytes returnedValue\\n    );\\n\\n    /**\\n     * @dev Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\\n     * @notice Reacted on received notification with `typeId` & `data`.\\n     *\\n     * @param typeId The hash of a specific standard or a hook.\\n     * @param data The arbitrary data received with the call.\\n     *\\n     * @custom:events {UniversalReceiver} event.\\n     */\\n    function universalReceiver(\\n        bytes32 typeId,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5b8764a678dc9d6673eafa8ad0ee6053cdea30acb58015bdf9c93f9f1788b49b\",\"license\":\"Apache-2.0\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"events":{"UniversalReceiver(address,uint256,bytes32,bytes,bytes)":{"notice":"Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`."}},"kind":"user","methods":{"universalReceiver(bytes32,bytes)":{"notice":"Reacted on received notification with `typeId` & `data`."}},"version":1}}},"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol":{"ILSP8IdentifiableDigitalAsset":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"DataChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"OperatorAuthorizationChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":false,"internalType":"bool","name":"notified","type":"bool"},{"indexed":false,"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"OperatorRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"TokenIdDataChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":false,"internalType":"bool","name":"force","type":"bool"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"authorizeOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOwner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"batchCalls","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataKey","type":"bytes32"}],"name":"getData","outputs":[{"internalType":"bytes","name":"dataValue","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"}],"name":"getDataBatch","outputs":[{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"tokenIds","type":"bytes32[]"},{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"}],"name":"getDataBatchForTokenIds","outputs":[{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bytes32","name":"dataKey","type":"bytes32"}],"name":"getDataForTokenId","outputs":[{"internalType":"bytes","name":"dataValues","type":"bytes"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"}],"name":"getOperatorsOf","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"}],"name":"isOperatorFor","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bool","name":"notify","type":"bool"},{"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"revokeOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"setData","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"},{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"name":"setDataBatch","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"tokenIds","type":"bytes32[]"},{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"},{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"name":"setDataBatchForTokenIds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"setDataForTokenId","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOwner","type":"address"}],"name":"tokenIdsOf","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"}],"name":"tokenOwnerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bool","name":"force","type":"bool"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"transfer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"from","type":"address[]"},{"internalType":"address[]","name":"to","type":"address[]"},{"internalType":"bytes32[]","name":"tokenId","type":"bytes32[]"},{"internalType":"bool[]","name":"force","type":"bool[]"},{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"transferBatch","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"events":{"DataChanged(bytes32,bytes)":{"details":"Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.","params":{"dataKey":"The data key for which a bytes value is set.","dataValue":"The value to set for the given data key."}},"OperatorAuthorizationChanged(address,address,bytes32,bytes)":{"details":"Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.","params":{"operator":"The address authorized as an operator.","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The tokenId `operator` address has access on behalf of `tokenOwner`.","tokenOwner":"The owner of the `tokenId`."}},"OperatorRevoked(address,address,bytes32,bool,bytes)":{"details":"Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.","params":{"notified":"Bool indicating whether the operator has been notified or not","operator":"The address revoked from the operator array ({getOperatorsOf}).","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The tokenId `operator` is revoked from operating on.","tokenOwner":"The owner of the `tokenId`."}},"TokenIdDataChanged(bytes32,bytes32,bytes)":{"details":"Emitted when setting data for `tokenId`.","params":{"dataKey":"The data key for which a bytes value is set.","dataValue":"The value to set for the given data key.","tokenId":"The tokenId which data is set for."}},"Transfer(address,address,address,bytes32,bool,bytes)":{"details":"Emitted when `tokenId` token is transferred from the `from` to the `to` address.","params":{"data":"Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.","force":"If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.","from":"The previous owner of the `tokenId`","operator":"The address of operator that sent the `tokenId`","to":"The new owner of `tokenId`","tokenId":"The tokenId that was transferred"}}},"kind":"dev","methods":{"authorizeOperator(address,bytes32,bytes)":{"custom:events":"{OperatorAuthorizationChanged} event.","custom:requirements":"- `tokenId` must exist. - caller MUST be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.","details":"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard","params":{"operator":"The address to authorize as an operator.","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The token ID operator has access to."}},"balanceOf(address)":{"details":"Get the number of token IDs owned by `tokenOwner`.","params":{"tokenOwner":"The address to query     *"},"returns":{"_0":"The total number of token IDs that `tokenOwner` owns."}},"batchCalls(bytes[])":{"details":"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.","params":{"data":"An array of ABI encoded function calls to be called on the contract."},"returns":{"results":"An array of abi-encoded data returned by the functions executed."}},"getData(bytes32)":{"details":"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.","params":{"dataKey":"The data key for which to retrieve the value."},"returns":{"dataValue":"The bytes value stored under the specified data key."}},"getDataBatch(bytes32[])":{"details":"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.","params":{"dataKeys":"The array of keys which values to retrieve"},"returns":{"dataValues":"The array of data stored at multiple keys"}},"getDataBatchForTokenIds(bytes32[],bytes32[])":{"params":{"dataKeys":"An array of data keys corresponding to the token IDs.","tokenIds":"An array of token IDs."},"returns":{"dataValues":"An array of data values for each pair of `tokenId` and `dataKey`."}},"getDataForTokenId(bytes32,bytes32)":{"params":{"dataKey":"The key for the data to retrieve.","tokenId":"The unique identifier for a token."},"returns":{"dataValues":"The data value associated with the given `tokenId` and `dataKey`."}},"getOperatorsOf(bytes32)":{"details":"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.","params":{"tokenId":"The token ID to get the operators for."},"returns":{"_0":"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}},"isOperatorFor(address,bytes32)":{"custom:info":"The tokenOwner is its own operator.","custom:requirements":"- `tokenId` must exist. - caller must be the current {tokenOwnerOf} `tokenId`.","details":"Returns whether `operator` address is an operator for a given `tokenId`.","params":{"operator":"The address to query operator status for.","tokenId":"The token ID to check if `operator` is allowed to operate on."},"returns":{"_0":"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}},"revokeOperator(address,bytes32,bool,bytes)":{"custom:events":"{OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..","custom:requirements":"- `tokenId` must exist. - caller must be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.","details":"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.","params":{"notify":"Boolean indicating whether to notify the operator or not","operator":"The address to revoke as an operator.","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The tokenId `operator` is revoked from operating on."}},"setData(bytes32,bytes)":{"details":"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.","params":{"dataKey":"The data key for which to set a new value.","dataValue":"The new bytes value to set."}},"setDataBatch(bytes32[],bytes[])":{"details":"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.","params":{"dataKeys":"An array of data keys to set bytes values for.","dataValues":"An array of bytes values to set for each `dataKeys`."}},"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])":{"custom:events":"{TokenIdDataChanged} event for each pair.","params":{"dataKeys":"An array of data keys corresponding to the token IDs.","dataValues":"An array of values to set for the given data keys.","tokenIds":"An array of token IDs."}},"setDataForTokenId(bytes32,bytes32,bytes)":{"custom:events":"{TokenIdDataChanged} event.","params":{"dataKey":"The key for the data to set.","dataValue":"The value to set for the given data key.","tokenId":"The unique identifier for a token."}},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"tokenIdsOf(address)":{"details":"Returns the list of token IDs that the `tokenOwner` address owns.","params":{"tokenOwner":"The address that we want to get the list of token IDs for."},"returns":{"_0":"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}},"tokenOwnerOf(bytes32)":{"custom:info":"if the `tokenId` is not owned by any address, the returned address will be `address(0)`","custom:requirements":"`tokenId` must exist.","details":"Returns the address that owns a given `tokenId`.","params":{"tokenId":"The token ID to query the owner for."},"returns":{"_0":"The owner address of the given `tokenId`."}},"totalSupply()":{"details":"Returns the number of existing tokens that have been minted in this contract.","returns":{"_0":"The number of existing tokens."}},"transfer(address,address,bytes32,bool,bytes)":{"custom:events":"- {Transfer} event when the `tokenId` is successfully transferred.","custom:hint":"The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.","custom:info":"if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.","custom:requirements":"- `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself). - `from` must own the given `tokenId`. - If the caller is not `from`, it must be an operator for the `tokenId`.","custom:warning":"Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified. This even if the `force` was set to `true`.","details":"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.","params":{"data":"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.","force":"When set to `true`, the `to` address CAN be any addres. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.","from":"The address that owns the given `tokenId`.","to":"The address that will receive the `tokenId`.","tokenId":"The token ID to transfer."}},"transferBatch(address[],address[],bytes32[],bool[],bytes[])":{"custom:events":"- {Transfer} events on each successful token transfer.","custom:requirements":"- The arrays of `from`, `to` and `tokenId` must have the same length. - no values in the `from` array can be the zero address. - no values in the `to` array can be the zero address. - `from` and `to` cannot be the same address at the same index on each arrays. - each `tokenId` must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`.","details":"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.","params":{"data":"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.","force":"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.","from":"An array of sending addresses.","to":"An array of recipient addresses.","tokenId":"An array of token IDs to transfer."}}},"title":"Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.","version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"authorizeOperator(address,bytes32,bytes)":"86a10ddd","balanceOf(address)":"70a08231","batchCalls(bytes[])":"6963d438","getData(bytes32)":"54f6127f","getDataBatch(bytes32[])":"dedff9c6","getDataBatchForTokenIds(bytes32[],bytes32[])":"1d26fce6","getDataForTokenId(bytes32,bytes32)":"16e023b3","getOperatorsOf(bytes32)":"49a6078d","isOperatorFor(address,bytes32)":"2a3654a4","revokeOperator(address,bytes32,bool,bytes)":"db8c9663","setData(bytes32,bytes)":"7f23690c","setDataBatch(bytes32[],bytes[])":"97902421","setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])":"be9f0e6f","setDataForTokenId(bytes32,bytes32,bytes)":"d6c1407c","supportsInterface(bytes4)":"01ffc9a7","tokenIdsOf(address)":"a3b261f2","tokenOwnerOf(bytes32)":"217b2270","totalSupply()":"18160ddd","transfer(address,address,bytes32,bool,bytes)":"511b6952","transferBatch(address[],address[],bytes32[],bool[],bytes[])":"7e87632c"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"DataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"OperatorAuthorizationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"notified\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"OperatorRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"TokenIdDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"batchCalls\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getDataBatch\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tokenIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getDataBatchForTokenIds\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"}],\"name\":\"getDataForTokenId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"dataValues\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"}],\"name\":\"getOperatorsOf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"setData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"name\":\"setDataBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tokenIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"name\":\"setDataBatchForTokenIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"setDataForTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"tokenIdsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"}],\"name\":\"tokenOwnerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"from\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenId\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"force\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"transferBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"DataChanged(bytes32,bytes)\":{\"details\":\"Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\",\"params\":{\"dataKey\":\"The data key for which a bytes value is set.\",\"dataValue\":\"The value to set for the given data key.\"}},\"OperatorAuthorizationChanged(address,address,bytes32,bytes)\":{\"details\":\"Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\",\"params\":{\"operator\":\"The address authorized as an operator.\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The tokenId `operator` address has access on behalf of `tokenOwner`.\",\"tokenOwner\":\"The owner of the `tokenId`.\"}},\"OperatorRevoked(address,address,bytes32,bool,bytes)\":{\"details\":\"Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\",\"params\":{\"notified\":\"Bool indicating whether the operator has been notified or not\",\"operator\":\"The address revoked from the operator array ({getOperatorsOf}).\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The tokenId `operator` is revoked from operating on.\",\"tokenOwner\":\"The owner of the `tokenId`.\"}},\"TokenIdDataChanged(bytes32,bytes32,bytes)\":{\"details\":\"Emitted when setting data for `tokenId`.\",\"params\":{\"dataKey\":\"The data key for which a bytes value is set.\",\"dataValue\":\"The value to set for the given data key.\",\"tokenId\":\"The tokenId which data is set for.\"}},\"Transfer(address,address,address,bytes32,bool,bytes)\":{\"details\":\"Emitted when `tokenId` token is transferred from the `from` to the `to` address.\",\"params\":{\"data\":\"Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\",\"force\":\"If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\",\"from\":\"The previous owner of the `tokenId`\",\"operator\":\"The address of operator that sent the `tokenId`\",\"to\":\"The new owner of `tokenId`\",\"tokenId\":\"The tokenId that was transferred\"}}},\"kind\":\"dev\",\"methods\":{\"authorizeOperator(address,bytes32,bytes)\":{\"custom:events\":\"{OperatorAuthorizationChanged} event.\",\"custom:requirements\":\"- `tokenId` must exist. - caller MUST be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.\",\"details\":\"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard\",\"params\":{\"operator\":\"The address to authorize as an operator.\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The token ID operator has access to.\"}},\"balanceOf(address)\":{\"details\":\"Get the number of token IDs owned by `tokenOwner`.\",\"params\":{\"tokenOwner\":\"The address to query     *\"},\"returns\":{\"_0\":\"The total number of token IDs that `tokenOwner` owns.\"}},\"batchCalls(bytes[])\":{\"details\":\"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\",\"params\":{\"data\":\"An array of ABI encoded function calls to be called on the contract.\"},\"returns\":{\"results\":\"An array of abi-encoded data returned by the functions executed.\"}},\"getData(bytes32)\":{\"details\":\"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\",\"params\":{\"dataKey\":\"The data key for which to retrieve the value.\"},\"returns\":{\"dataValue\":\"The bytes value stored under the specified data key.\"}},\"getDataBatch(bytes32[])\":{\"details\":\"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\",\"params\":{\"dataKeys\":\"The array of keys which values to retrieve\"},\"returns\":{\"dataValues\":\"The array of data stored at multiple keys\"}},\"getDataBatchForTokenIds(bytes32[],bytes32[])\":{\"params\":{\"dataKeys\":\"An array of data keys corresponding to the token IDs.\",\"tokenIds\":\"An array of token IDs.\"},\"returns\":{\"dataValues\":\"An array of data values for each pair of `tokenId` and `dataKey`.\"}},\"getDataForTokenId(bytes32,bytes32)\":{\"params\":{\"dataKey\":\"The key for the data to retrieve.\",\"tokenId\":\"The unique identifier for a token.\"},\"returns\":{\"dataValues\":\"The data value associated with the given `tokenId` and `dataKey`.\"}},\"getOperatorsOf(bytes32)\":{\"details\":\"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\",\"params\":{\"tokenId\":\"The token ID to get the operators for.\"},\"returns\":{\"_0\":\"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist.\"}},\"isOperatorFor(address,bytes32)\":{\"custom:info\":\"The tokenOwner is its own operator.\",\"custom:requirements\":\"- `tokenId` must exist. - caller must be the current {tokenOwnerOf} `tokenId`.\",\"details\":\"Returns whether `operator` address is an operator for a given `tokenId`.\",\"params\":{\"operator\":\"The address to query operator status for.\",\"tokenId\":\"The token ID to check if `operator` is allowed to operate on.\"},\"returns\":{\"_0\":\"`true` if `operator` is an operator for `tokenId`, `false` otherwise.\"}},\"revokeOperator(address,bytes32,bool,bytes)\":{\"custom:events\":\"{OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\",\"custom:requirements\":\"- `tokenId` must exist. - caller must be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.\",\"details\":\"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.\",\"params\":{\"notify\":\"Boolean indicating whether to notify the operator or not\",\"operator\":\"The address to revoke as an operator.\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The tokenId `operator` is revoked from operating on.\"}},\"setData(bytes32,bytes)\":{\"details\":\"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.\",\"params\":{\"dataKey\":\"The data key for which to set a new value.\",\"dataValue\":\"The new bytes value to set.\"}},\"setDataBatch(bytes32[],bytes[])\":{\"details\":\"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\",\"params\":{\"dataKeys\":\"An array of data keys to set bytes values for.\",\"dataValues\":\"An array of bytes values to set for each `dataKeys`.\"}},\"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])\":{\"custom:events\":\"{TokenIdDataChanged} event for each pair.\",\"params\":{\"dataKeys\":\"An array of data keys corresponding to the token IDs.\",\"dataValues\":\"An array of values to set for the given data keys.\",\"tokenIds\":\"An array of token IDs.\"}},\"setDataForTokenId(bytes32,bytes32,bytes)\":{\"custom:events\":\"{TokenIdDataChanged} event.\",\"params\":{\"dataKey\":\"The key for the data to set.\",\"dataValue\":\"The value to set for the given data key.\",\"tokenId\":\"The unique identifier for a token.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"},\"tokenIdsOf(address)\":{\"details\":\"Returns the list of token IDs that the `tokenOwner` address owns.\",\"params\":{\"tokenOwner\":\"The address that we want to get the list of token IDs for.\"},\"returns\":{\"_0\":\"An array of `bytes32[] tokenIds` owned by `tokenOwner`.\"}},\"tokenOwnerOf(bytes32)\":{\"custom:info\":\"if the `tokenId` is not owned by any address, the returned address will be `address(0)`\",\"custom:requirements\":\"`tokenId` must exist.\",\"details\":\"Returns the address that owns a given `tokenId`.\",\"params\":{\"tokenId\":\"The token ID to query the owner for.\"},\"returns\":{\"_0\":\"The owner address of the given `tokenId`.\"}},\"totalSupply()\":{\"details\":\"Returns the number of existing tokens that have been minted in this contract.\",\"returns\":{\"_0\":\"The number of existing tokens.\"}},\"transfer(address,address,bytes32,bool,bytes)\":{\"custom:events\":\"- {Transfer} event when the `tokenId` is successfully transferred.\",\"custom:hint\":\"The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\",\"custom:info\":\"if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\",\"custom:requirements\":\"- `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself). - `from` must own the given `tokenId`. - If the caller is not `from`, it must be an operator for the `tokenId`.\",\"custom:warning\":\"Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified. This even if the `force` was set to `true`.\",\"details\":\"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.\",\"params\":{\"data\":\"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\",\"force\":\"When set to `true`, the `to` address CAN be any addres. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\",\"from\":\"The address that owns the given `tokenId`.\",\"to\":\"The address that will receive the `tokenId`.\",\"tokenId\":\"The token ID to transfer.\"}},\"transferBatch(address[],address[],bytes32[],bool[],bytes[])\":{\"custom:events\":\"- {Transfer} events on each successful token transfer.\",\"custom:requirements\":\"- The arrays of `from`, `to` and `tokenId` must have the same length. - no values in the `from` array can be the zero address. - no values in the `to` array can be the zero address. - `from` and `to` cannot be the same address at the same index on each arrays. - each `tokenId` must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`.\",\"details\":\"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.\",\"params\":{\"data\":\"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\",\"force\":\"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\",\"from\":\"An array of sending addresses.\",\"to\":\"An array of recipient addresses.\",\"tokenId\":\"An array of token IDs to transfer.\"}}},\"title\":\"Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.\",\"version\":1},\"userdoc\":{\"events\":{\"DataChanged(bytes32,bytes)\":{\"notice\":\"The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\"}},\"kind\":\"user\",\"methods\":{\"batchCalls(bytes[])\":{\"notice\":\"Executing the following batch of abi-encoded function calls on the contract: `data`.\"},\"getData(bytes32)\":{\"notice\":\"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\"},\"getDataBatch(bytes32[])\":{\"notice\":\"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\"},\"getDataBatchForTokenIds(bytes32[],bytes32[])\":{\"notice\":\"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\"},\"getDataForTokenId(bytes32,bytes32)\":{\"notice\":\"Retrieves data for a specific `tokenId` and `dataKey`.\"},\"setData(bytes32,bytes)\":{\"notice\":\"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\"},\"setDataBatch(bytes32[],bytes[])\":{\"notice\":\"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\"},\"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])\":{\"notice\":\"Sets data in batch for multiple `tokenId` and `dataKey` pairs.\"},\"setDataForTokenId(bytes32,bytes32,bytes)\":{\"notice\":\"Sets data for a specific `tokenId` and `dataKey`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\":\"ILSP8IdentifiableDigitalAsset\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\\n */\\ninterface IERC725Y is IERC165 {\\n    /**\\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\\n     * @param dataKey The data key for which to retrieve the value.\\n     * @return dataValue The bytes value stored under the specified data key.\\n     */\\n    function getData(\\n        bytes32 dataKey\\n    ) external view returns (bytes memory dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\\n     * @param dataKeys The array of keys which values to retrieve\\n     * @return dataValues The array of data stored at multiple keys\\n     */\\n    function getDataBatch(\\n        bytes32[] memory dataKeys\\n    ) external view returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\\n     *\\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\\n     * a fee mechanism for setting specific data.\\n     *\\n     * @param dataKey The data key for which to set a new value.\\n     * @param dataValue The new bytes value to set.\\n     */\\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\\n\\n    /**\\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\\n     *\\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\\n     *\\n     * @param dataKeys An array of data keys to set bytes values for.\\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\\n     */\\n    function setDataBatch(\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xa47c9e3eba0c733a1685b9fa309f753540c89ad2dca73236a2c953e7f5680e7b\",\"license\":\"CC0-1.0\"},\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {\\n    IERC725Y\\n} from \\\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\\\";\\n\\n/**\\n * @title Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.\\n */\\ninterface ILSP8IdentifiableDigitalAsset is IERC165, IERC725Y {\\n    // --- Events\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from the `from` to the `to` address.\\n     * @param operator The address of operator that sent the `tokenId`\\n     * @param from The previous owner of the `tokenId`\\n     * @param to The new owner of `tokenId`\\n     * @param tokenId The tokenId that was transferred\\n     * @param force If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\\n     * @param data Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\\n     */\\n    event Transfer(\\n        address operator,\\n        address indexed from,\\n        address indexed to,\\n        bytes32 indexed tokenId,\\n        bool force,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\\n     * @param operator The address authorized as an operator.\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` address has access on behalf of `tokenOwner`.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorAuthorizationChanged(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\\n     * @param operator The address revoked from the operator array ({getOperatorsOf}).\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notified Bool indicating whether the operator has been notified or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorRevoked(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bool notified,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when setting data for `tokenId`.\\n     * @param tokenId The tokenId which data is set for.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event TokenIdDataChanged(\\n        bytes32 indexed tokenId,\\n        bytes32 indexed dataKey,\\n        bytes dataValue\\n    );\\n\\n    // --- Token queries\\n\\n    /**\\n     * @dev Returns the number of existing tokens that have been minted in this contract.\\n     * @return The number of existing tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // --- Token owner queries\\n\\n    /**\\n     * @dev Get the number of token IDs owned by `tokenOwner`.\\n\\n     * @param tokenOwner The address to query     *\\n     * @return The total number of token IDs that `tokenOwner` owns.\\n     */\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the address that owns a given `tokenId`.\\n     *\\n     * @param tokenId The token ID to query the owner for.\\n     * @return The owner address of the given `tokenId`.\\n     *\\n     * @custom:requirements `tokenId` must exist.\\n     * @custom:info if the `tokenId` is not owned by any address, the returned address will be `address(0)`\\n     */\\n    function tokenOwnerOf(bytes32 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Returns the list of token IDs that the `tokenOwner` address owns.\\n     * @param tokenOwner The address that we want to get the list of token IDs for.\\n     * @return An array of `bytes32[] tokenIds` owned by `tokenOwner`.\\n     */\\n    function tokenIdsOf(\\n        address tokenOwner\\n    ) external view returns (bytes32[] memory);\\n\\n    // --- TokenId Metadata functionality\\n\\n    /**\\n     * @notice Retrieves data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to retrieve.\\n     * @return dataValues The data value associated with the given `tokenId` and `dataKey`.\\n     */\\n    function getDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey\\n    ) external returns (bytes memory dataValues);\\n\\n    /**\\n     * @notice Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @return dataValues An array of data values for each pair of `tokenId` and `dataKey`.\\n     */\\n    function getDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys\\n    ) external returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Sets data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to set.\\n     * @param dataValue The value to set for the given data key.\\n     * @custom:events {TokenIdDataChanged} event.\\n     */\\n    function setDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey,\\n        bytes memory dataValue\\n    ) external;\\n\\n    /**\\n     * @notice Sets data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @param dataValues An array of values to set for the given data keys.\\n     * @custom:events {TokenIdDataChanged} event for each pair.\\n     */\\n    function setDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external;\\n\\n    // --- Operator functionality\\n\\n    /**\\n     * @dev Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}.\\n     * Notify the operator based on the LSP1-UniversalReceiver standard\\n     *\\n     * @param operator The address to authorize as an operator.\\n     * @param tokenId The token ID operator has access to.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller MUST be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorAuthorizationChanged} event.\\n     */\\n    function authorizeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner.\\n     * See also {isOperatorFor}.\\n     *\\n     * @param operator The address to revoke as an operator.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notify Boolean indicating whether to notify the operator or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\\n     */\\n    function revokeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bool notify,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Returns whether `operator` address is an operator for a given `tokenId`.\\n     *\\n     * @param operator The address to query operator status for.\\n     * @param tokenId The token ID to check if `operator` is allowed to operate on.\\n     *\\n     * @return `true` if `operator` is an operator for `tokenId`, `false` otherwise.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the current {tokenOwnerOf} `tokenId`.\\n     *\\n     * @custom:info The tokenOwner is its own operator.\\n     */\\n    function isOperatorFor(\\n        address operator,\\n        bytes32 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\\n     *\\n     * @param tokenId The token ID to get the operators for.\\n     * @return An array of operators allowed to transfer or burn a specific `tokenId`.\\n     *\\n     * Requirements\\n     * - `tokenId` must exist.\\n     */\\n    function getOperatorsOf(\\n        bytes32 tokenId\\n    ) external view returns (address[] memory);\\n\\n    // --- Transfer functionality\\n\\n    /**\\n     * @dev Transfer a given `tokenId` token from the `from` address to the `to` address.\\n     *\\n     * If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred.\\n     *\\n     * The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 standard.\\n     *\\n     * @param from The address that owns the given `tokenId`.\\n     * @param to The address that will receive the `tokenId`.\\n     * @param tokenId The token ID to transfer.\\n     * @param force When set to `true`, the `to` address CAN be any addres.\\n     * When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\\n     *\\n     * @custom:requirements\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself).\\n     * - `from` must own the given `tokenId`.\\n     * - If the caller is not `from`, it must be an operator for the `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} event when the `tokenId` is successfully transferred.\\n     *\\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\\n     *\\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\\n     *\\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\\n     * This even if the `force` was set to `true`.\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        bytes32 tokenId,\\n        bool force,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`.\\n     * If any transfer fails, the whole call will revert.\\n     *\\n     * @param from An array of sending addresses.\\n     * @param to An array of recipient addresses.\\n     * @param tokenId An array of token IDs to transfer.\\n     * @param force When set to `true`, `to` may be any address.\\n     * When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\\n     *\\n     *\\n     * @custom:requirements\\n     * - The arrays of `from`, `to` and `tokenId` must have the same length.\\n     * - no values in the `from` array can be the zero address.\\n     * - no values in the `to` array can be the zero address.\\n     * - `from` and `to` cannot be the same address at the same index on each arrays.\\n     * - each `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be an operator of each `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} events on each successful token transfer.\\n     */\\n    function transferBatch(\\n        address[] memory from,\\n        address[] memory to,\\n        bytes32[] memory tokenId,\\n        bool[] memory force,\\n        bytes[] memory data\\n    ) external;\\n\\n    /**\\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\\n     *\\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\\n     * @param data An array of ABI encoded function calls to be called on the contract.\\n     * @return results An array of abi-encoded data returned by the functions executed.\\n     */\\n    function batchCalls(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x16dccaeb35168c4e61763a2c35b075eeed7505661b10fc9c16194af6eb3751ad\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"events":{"DataChanged(bytes32,bytes)":{"notice":"The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`."}},"kind":"user","methods":{"batchCalls(bytes[])":{"notice":"Executing the following batch of abi-encoded function calls on the contract: `data`."},"getData(bytes32)":{"notice":"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."},"getDataBatch(bytes32[])":{"notice":"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."},"getDataBatchForTokenIds(bytes32[],bytes32[])":{"notice":"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."},"getDataForTokenId(bytes32,bytes32)":{"notice":"Retrieves data for a specific `tokenId` and `dataKey`."},"setData(bytes32,bytes)":{"notice":"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."},"setDataBatch(bytes32[],bytes[])":{"notice":"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."},"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])":{"notice":"Sets data in batch for multiple `tokenId` and `dataKey` pairs."},"setDataForTokenId(bytes32,bytes32,bytes)":{"notice":"Sets data for a specific `tokenId` and `dataKey`."}},"version":1}}},"@openzeppelin/contracts/utils/introspection/ERC165.sol":{"ERC165":{"abi":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"devdoc":{"details":"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"supportsInterface(bytes4)":"01ffc9a7"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implementation of the {IERC165} interface. Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":\"ERC165\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}}},"@openzeppelin/contracts/utils/introspection/IERC165.sol":{"IERC165":{"abi":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"devdoc":{"details":"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"supportsInterface(bytes4)":"01ffc9a7"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[EIP]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":\"IERC165\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}}},"contracts/interfaces/IShirts.sol":{"IShirts":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"DataChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"OperatorAuthorizationChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"tokenOwner","type":"address"},{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":false,"internalType":"bool","name":"notified","type":"bool"},{"indexed":false,"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"OperatorRevoked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"_recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"ShirtsMinted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"TokenIdDataChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"indexed":false,"internalType":"bool","name":"force","type":"bool"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"authorizeOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOwner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"batchCalls","outputs":[{"internalType":"bytes[]","name":"results","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataKey","type":"bytes32"}],"name":"getData","outputs":[{"internalType":"bytes","name":"dataValue","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"}],"name":"getDataBatch","outputs":[{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"tokenIds","type":"bytes32[]"},{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"}],"name":"getDataBatchForTokenIds","outputs":[{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bytes32","name":"dataKey","type":"bytes32"}],"name":"getDataForTokenId","outputs":[{"internalType":"bytes","name":"dataValues","type":"bytes"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"}],"name":"getOperatorsOf","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPrice","outputs":[{"internalType":"uint256","name":"price","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPrizePool","outputs":[{"internalType":"address","name":"prizePool","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"}],"name":"isOperatorFor","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_recipient","type":"address"},{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bool","name":"notify","type":"bool"},{"internalType":"bytes","name":"operatorNotificationData","type":"bytes"}],"name":"revokeOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"setData","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"},{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"name":"setDataBatch","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"tokenIds","type":"bytes32[]"},{"internalType":"bytes32[]","name":"dataKeys","type":"bytes32[]"},{"internalType":"bytes[]","name":"dataValues","type":"bytes[]"}],"name":"setDataBatchForTokenIds","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bytes32","name":"dataKey","type":"bytes32"},{"internalType":"bytes","name":"dataValue","type":"bytes"}],"name":"setDataForTokenId","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenOwner","type":"address"}],"name":"tokenIdsOf","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"tokenId","type":"bytes32"}],"name":"tokenOwnerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bool","name":"force","type":"bool"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"transfer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"from","type":"address[]"},{"internalType":"address[]","name":"to","type":"address[]"},{"internalType":"bytes32[]","name":"tokenId","type":"bytes32[]"},{"internalType":"bool[]","name":"force","type":"bool[]"},{"internalType":"bytes[]","name":"data","type":"bytes[]"}],"name":"transferBatch","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"events":{"DataChanged(bytes32,bytes)":{"details":"Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.","params":{"dataKey":"The data key for which a bytes value is set.","dataValue":"The value to set for the given data key."}},"OperatorAuthorizationChanged(address,address,bytes32,bytes)":{"details":"Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.","params":{"operator":"The address authorized as an operator.","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The tokenId `operator` address has access on behalf of `tokenOwner`.","tokenOwner":"The owner of the `tokenId`."}},"OperatorRevoked(address,address,bytes32,bool,bytes)":{"details":"Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.","params":{"notified":"Bool indicating whether the operator has been notified or not","operator":"The address revoked from the operator array ({getOperatorsOf}).","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The tokenId `operator` is revoked from operating on.","tokenOwner":"The owner of the `tokenId`."}},"TokenIdDataChanged(bytes32,bytes32,bytes)":{"details":"Emitted when setting data for `tokenId`.","params":{"dataKey":"The data key for which a bytes value is set.","dataValue":"The value to set for the given data key.","tokenId":"The tokenId which data is set for."}},"Transfer(address,address,address,bytes32,bool,bytes)":{"details":"Emitted when `tokenId` token is transferred from the `from` to the `to` address.","params":{"data":"Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.","force":"If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.","from":"The previous owner of the `tokenId`","operator":"The address of operator that sent the `tokenId`","to":"The new owner of `tokenId`","tokenId":"The tokenId that was transferred"}}},"kind":"dev","methods":{"authorizeOperator(address,bytes32,bytes)":{"custom:events":"{OperatorAuthorizationChanged} event.","custom:requirements":"- `tokenId` must exist. - caller MUST be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.","details":"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard","params":{"operator":"The address to authorize as an operator.","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The token ID operator has access to."}},"balanceOf(address)":{"details":"Get the number of token IDs owned by `tokenOwner`.","params":{"tokenOwner":"The address to query     *"},"returns":{"_0":"The total number of token IDs that `tokenOwner` owns."}},"batchCalls(bytes[])":{"details":"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.","params":{"data":"An array of ABI encoded function calls to be called on the contract."},"returns":{"results":"An array of abi-encoded data returned by the functions executed."}},"getData(bytes32)":{"details":"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.","params":{"dataKey":"The data key for which to retrieve the value."},"returns":{"dataValue":"The bytes value stored under the specified data key."}},"getDataBatch(bytes32[])":{"details":"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.","params":{"dataKeys":"The array of keys which values to retrieve"},"returns":{"dataValues":"The array of data stored at multiple keys"}},"getDataBatchForTokenIds(bytes32[],bytes32[])":{"params":{"dataKeys":"An array of data keys corresponding to the token IDs.","tokenIds":"An array of token IDs."},"returns":{"dataValues":"An array of data values for each pair of `tokenId` and `dataKey`."}},"getDataForTokenId(bytes32,bytes32)":{"params":{"dataKey":"The key for the data to retrieve.","tokenId":"The unique identifier for a token."},"returns":{"dataValues":"The data value associated with the given `tokenId` and `dataKey`."}},"getOperatorsOf(bytes32)":{"details":"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.","params":{"tokenId":"The token ID to get the operators for."},"returns":{"_0":"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist."}},"isOperatorFor(address,bytes32)":{"custom:info":"The tokenOwner is its own operator.","custom:requirements":"- `tokenId` must exist. - caller must be the current {tokenOwnerOf} `tokenId`.","details":"Returns whether `operator` address is an operator for a given `tokenId`.","params":{"operator":"The address to query operator status for.","tokenId":"The token ID to check if `operator` is allowed to operate on."},"returns":{"_0":"`true` if `operator` is an operator for `tokenId`, `false` otherwise."}},"revokeOperator(address,bytes32,bool,bytes)":{"custom:events":"{OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..","custom:requirements":"- `tokenId` must exist. - caller must be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.","details":"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.","params":{"notify":"Boolean indicating whether to notify the operator or not","operator":"The address to revoke as an operator.","operatorNotificationData":"The data to notify the operator about via LSP1.","tokenId":"The tokenId `operator` is revoked from operating on."}},"setData(bytes32,bytes)":{"details":"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.","params":{"dataKey":"The data key for which to set a new value.","dataValue":"The new bytes value to set."}},"setDataBatch(bytes32[],bytes[])":{"details":"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.","params":{"dataKeys":"An array of data keys to set bytes values for.","dataValues":"An array of bytes values to set for each `dataKeys`."}},"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])":{"custom:events":"{TokenIdDataChanged} event for each pair.","params":{"dataKeys":"An array of data keys corresponding to the token IDs.","dataValues":"An array of values to set for the given data keys.","tokenIds":"An array of token IDs."}},"setDataForTokenId(bytes32,bytes32,bytes)":{"custom:events":"{TokenIdDataChanged} event.","params":{"dataKey":"The key for the data to set.","dataValue":"The value to set for the given data key.","tokenId":"The unique identifier for a token."}},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"tokenIdsOf(address)":{"details":"Returns the list of token IDs that the `tokenOwner` address owns.","params":{"tokenOwner":"The address that we want to get the list of token IDs for."},"returns":{"_0":"An array of `bytes32[] tokenIds` owned by `tokenOwner`."}},"tokenOwnerOf(bytes32)":{"custom:info":"if the `tokenId` is not owned by any address, the returned address will be `address(0)`","custom:requirements":"`tokenId` must exist.","details":"Returns the address that owns a given `tokenId`.","params":{"tokenId":"The token ID to query the owner for."},"returns":{"_0":"The owner address of the given `tokenId`."}},"totalSupply()":{"details":"Returns the number of existing tokens that have been minted in this contract.","returns":{"_0":"The number of existing tokens."}},"transfer(address,address,bytes32,bool,bytes)":{"custom:events":"- {Transfer} event when the `tokenId` is successfully transferred.","custom:hint":"The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.","custom:info":"if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.","custom:requirements":"- `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself). - `from` must own the given `tokenId`. - If the caller is not `from`, it must be an operator for the `tokenId`.","custom:warning":"Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified. This even if the `force` was set to `true`.","details":"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.","params":{"data":"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.","force":"When set to `true`, the `to` address CAN be any addres. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.","from":"The address that owns the given `tokenId`.","to":"The address that will receive the `tokenId`.","tokenId":"The token ID to transfer."}},"transferBatch(address[],address[],bytes32[],bool[],bytes[])":{"custom:events":"- {Transfer} events on each successful token transfer.","custom:requirements":"- The arrays of `from`, `to` and `tokenId` must have the same length. - no values in the `from` array can be the zero address. - no values in the `to` array can be the zero address. - `from` and `to` cannot be the same address at the same index on each arrays. - each `tokenId` must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`.","details":"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.","params":{"data":"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.","force":"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.","from":"An array of sending addresses.","to":"An array of recipient addresses.","tokenId":"An array of token IDs to transfer."}}},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"authorizeOperator(address,bytes32,bytes)":"86a10ddd","balanceOf(address)":"70a08231","batchCalls(bytes[])":"6963d438","getData(bytes32)":"54f6127f","getDataBatch(bytes32[])":"dedff9c6","getDataBatchForTokenIds(bytes32[],bytes32[])":"1d26fce6","getDataForTokenId(bytes32,bytes32)":"16e023b3","getOperatorsOf(bytes32)":"49a6078d","getPrice()":"98d5fdca","getPrizePool()":"884bf67c","isOperatorFor(address,bytes32)":"2a3654a4","mint(address,uint256)":"40c10f19","revokeOperator(address,bytes32,bool,bytes)":"db8c9663","setData(bytes32,bytes)":"7f23690c","setDataBatch(bytes32[],bytes[])":"97902421","setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])":"be9f0e6f","setDataForTokenId(bytes32,bytes32,bytes)":"d6c1407c","supportsInterface(bytes4)":"01ffc9a7","tokenIdsOf(address)":"a3b261f2","tokenOwnerOf(bytes32)":"217b2270","totalSupply()":"18160ddd","transfer(address,address,bytes32,bool,bytes)":"511b6952","transferBatch(address[],address[],bytes32[],bool[],bytes[])":"7e87632c"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"DataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"OperatorAuthorizationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"notified\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"OperatorRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ShirtsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"TokenIdDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"batchCalls\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"}],\"name\":\"getData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getDataBatch\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tokenIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"}],\"name\":\"getDataBatchForTokenIds\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"}],\"name\":\"getDataForTokenId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"dataValues\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"}],\"name\":\"getOperatorsOf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"prizePool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"operatorNotificationData\",\"type\":\"bytes\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"setData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"name\":\"setDataBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"tokenIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"dataKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataValues\",\"type\":\"bytes[]\"}],\"name\":\"setDataBatchForTokenIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"dataValue\",\"type\":\"bytes\"}],\"name\":\"setDataForTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"tokenIdsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"}],\"name\":\"tokenOwnerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"from\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"tokenId\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool[]\",\"name\":\"force\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"transferBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"DataChanged(bytes32,bytes)\":{\"details\":\"Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\",\"params\":{\"dataKey\":\"The data key for which a bytes value is set.\",\"dataValue\":\"The value to set for the given data key.\"}},\"OperatorAuthorizationChanged(address,address,bytes32,bytes)\":{\"details\":\"Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\",\"params\":{\"operator\":\"The address authorized as an operator.\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The tokenId `operator` address has access on behalf of `tokenOwner`.\",\"tokenOwner\":\"The owner of the `tokenId`.\"}},\"OperatorRevoked(address,address,bytes32,bool,bytes)\":{\"details\":\"Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\",\"params\":{\"notified\":\"Bool indicating whether the operator has been notified or not\",\"operator\":\"The address revoked from the operator array ({getOperatorsOf}).\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The tokenId `operator` is revoked from operating on.\",\"tokenOwner\":\"The owner of the `tokenId`.\"}},\"TokenIdDataChanged(bytes32,bytes32,bytes)\":{\"details\":\"Emitted when setting data for `tokenId`.\",\"params\":{\"dataKey\":\"The data key for which a bytes value is set.\",\"dataValue\":\"The value to set for the given data key.\",\"tokenId\":\"The tokenId which data is set for.\"}},\"Transfer(address,address,address,bytes32,bool,bytes)\":{\"details\":\"Emitted when `tokenId` token is transferred from the `from` to the `to` address.\",\"params\":{\"data\":\"Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\",\"force\":\"If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\",\"from\":\"The previous owner of the `tokenId`\",\"operator\":\"The address of operator that sent the `tokenId`\",\"to\":\"The new owner of `tokenId`\",\"tokenId\":\"The tokenId that was transferred\"}}},\"kind\":\"dev\",\"methods\":{\"authorizeOperator(address,bytes32,bytes)\":{\"custom:events\":\"{OperatorAuthorizationChanged} event.\",\"custom:requirements\":\"- `tokenId` must exist. - caller MUST be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.\",\"details\":\"Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}. Notify the operator based on the LSP1-UniversalReceiver standard\",\"params\":{\"operator\":\"The address to authorize as an operator.\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The token ID operator has access to.\"}},\"balanceOf(address)\":{\"details\":\"Get the number of token IDs owned by `tokenOwner`.\",\"params\":{\"tokenOwner\":\"The address to query     *\"},\"returns\":{\"_0\":\"The total number of token IDs that `tokenOwner` owns.\"}},\"batchCalls(bytes[])\":{\"details\":\"Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\",\"params\":{\"data\":\"An array of ABI encoded function calls to be called on the contract.\"},\"returns\":{\"results\":\"An array of abi-encoded data returned by the functions executed.\"}},\"getData(bytes32)\":{\"details\":\"Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\",\"params\":{\"dataKey\":\"The data key for which to retrieve the value.\"},\"returns\":{\"dataValue\":\"The bytes value stored under the specified data key.\"}},\"getDataBatch(bytes32[])\":{\"details\":\"Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\",\"params\":{\"dataKeys\":\"The array of keys which values to retrieve\"},\"returns\":{\"dataValues\":\"The array of data stored at multiple keys\"}},\"getDataBatchForTokenIds(bytes32[],bytes32[])\":{\"params\":{\"dataKeys\":\"An array of data keys corresponding to the token IDs.\",\"tokenIds\":\"An array of token IDs.\"},\"returns\":{\"dataValues\":\"An array of data values for each pair of `tokenId` and `dataKey`.\"}},\"getDataForTokenId(bytes32,bytes32)\":{\"params\":{\"dataKey\":\"The key for the data to retrieve.\",\"tokenId\":\"The unique identifier for a token.\"},\"returns\":{\"dataValues\":\"The data value associated with the given `tokenId` and `dataKey`.\"}},\"getOperatorsOf(bytes32)\":{\"details\":\"Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\",\"params\":{\"tokenId\":\"The token ID to get the operators for.\"},\"returns\":{\"_0\":\"An array of operators allowed to transfer or burn a specific `tokenId`. Requirements - `tokenId` must exist.\"}},\"isOperatorFor(address,bytes32)\":{\"custom:info\":\"The tokenOwner is its own operator.\",\"custom:requirements\":\"- `tokenId` must exist. - caller must be the current {tokenOwnerOf} `tokenId`.\",\"details\":\"Returns whether `operator` address is an operator for a given `tokenId`.\",\"params\":{\"operator\":\"The address to query operator status for.\",\"tokenId\":\"The token ID to check if `operator` is allowed to operate on.\"},\"returns\":{\"_0\":\"`true` if `operator` is an operator for `tokenId`, `false` otherwise.\"}},\"revokeOperator(address,bytes32,bool,bytes)\":{\"custom:events\":\"{OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\",\"custom:requirements\":\"- `tokenId` must exist. - caller must be the {tokenOwnerOf} `tokenId`. - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address). - `operator` cannot be the zero address.\",\"details\":\"Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner. See also {isOperatorFor}.\",\"params\":{\"notify\":\"Boolean indicating whether to notify the operator or not\",\"operator\":\"The address to revoke as an operator.\",\"operatorNotificationData\":\"The data to notify the operator about via LSP1.\",\"tokenId\":\"The tokenId `operator` is revoked from operating on.\"}},\"setData(bytes32,bytes)\":{\"details\":\"Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`. The function is marked as payable to enable flexibility on child contracts. For instance to implement a fee mechanism for setting specific data.\",\"params\":{\"dataKey\":\"The data key for which to set a new value.\",\"dataValue\":\"The new bytes value to set.\"}},\"setDataBatch(bytes32[],bytes[])\":{\"details\":\"Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\",\"params\":{\"dataKeys\":\"An array of data keys to set bytes values for.\",\"dataValues\":\"An array of bytes values to set for each `dataKeys`.\"}},\"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])\":{\"custom:events\":\"{TokenIdDataChanged} event for each pair.\",\"params\":{\"dataKeys\":\"An array of data keys corresponding to the token IDs.\",\"dataValues\":\"An array of values to set for the given data keys.\",\"tokenIds\":\"An array of token IDs.\"}},\"setDataForTokenId(bytes32,bytes32,bytes)\":{\"custom:events\":\"{TokenIdDataChanged} event.\",\"params\":{\"dataKey\":\"The key for the data to set.\",\"dataValue\":\"The value to set for the given data key.\",\"tokenId\":\"The unique identifier for a token.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"},\"tokenIdsOf(address)\":{\"details\":\"Returns the list of token IDs that the `tokenOwner` address owns.\",\"params\":{\"tokenOwner\":\"The address that we want to get the list of token IDs for.\"},\"returns\":{\"_0\":\"An array of `bytes32[] tokenIds` owned by `tokenOwner`.\"}},\"tokenOwnerOf(bytes32)\":{\"custom:info\":\"if the `tokenId` is not owned by any address, the returned address will be `address(0)`\",\"custom:requirements\":\"`tokenId` must exist.\",\"details\":\"Returns the address that owns a given `tokenId`.\",\"params\":{\"tokenId\":\"The token ID to query the owner for.\"},\"returns\":{\"_0\":\"The owner address of the given `tokenId`.\"}},\"totalSupply()\":{\"details\":\"Returns the number of existing tokens that have been minted in this contract.\",\"returns\":{\"_0\":\"The number of existing tokens.\"}},\"transfer(address,address,bytes32,bool,bytes)\":{\"custom:events\":\"- {Transfer} event when the `tokenId` is successfully transferred.\",\"custom:hint\":\"The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\",\"custom:info\":\"if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\",\"custom:requirements\":\"- `from` cannot be the zero address. - `to` cannot be the zero address. - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself). - `from` must own the given `tokenId`. - If the caller is not `from`, it must be an operator for the `tokenId`.\",\"custom:warning\":\"Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified. This even if the `force` was set to `true`.\",\"details\":\"Transfer a given `tokenId` token from the `from` address to the `to` address. If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred. The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs) or contracts that do not implement the LSP1 standard.\",\"params\":{\"data\":\"Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\",\"force\":\"When set to `true`, the `to` address CAN be any addres. When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\",\"from\":\"The address that owns the given `tokenId`.\",\"to\":\"The address that will receive the `tokenId`.\",\"tokenId\":\"The token ID to transfer.\"}},\"transferBatch(address[],address[],bytes32[],bool[],bytes[])\":{\"custom:events\":\"- {Transfer} events on each successful token transfer.\",\"custom:requirements\":\"- The arrays of `from`, `to` and `tokenId` must have the same length. - no values in the `from` array can be the zero address. - no values in the `to` array can be the zero address. - `from` and `to` cannot be the same address at the same index on each arrays. - each `tokenId` must be owned by `from`. - If the caller is not `from`, it must be an operator of each `tokenId`.\",\"details\":\"Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`. If any transfer fails, the whole call will revert.\",\"params\":{\"data\":\"Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\",\"force\":\"When set to `true`, `to` may be any address. When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\",\"from\":\"An array of sending addresses.\",\"to\":\"An array of recipient addresses.\",\"tokenId\":\"An array of token IDs to transfer.\"}}},\"version\":1},\"userdoc\":{\"events\":{\"DataChanged(bytes32,bytes)\":{\"notice\":\"The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\"}},\"kind\":\"user\",\"methods\":{\"batchCalls(bytes[])\":{\"notice\":\"Executing the following batch of abi-encoded function calls on the contract: `data`.\"},\"getData(bytes32)\":{\"notice\":\"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\"},\"getDataBatch(bytes32[])\":{\"notice\":\"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\"},\"getDataBatchForTokenIds(bytes32[],bytes32[])\":{\"notice\":\"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\"},\"getDataForTokenId(bytes32,bytes32)\":{\"notice\":\"Retrieves data for a specific `tokenId` and `dataKey`.\"},\"setData(bytes32,bytes)\":{\"notice\":\"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\"},\"setDataBatch(bytes32[],bytes[])\":{\"notice\":\"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\"},\"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])\":{\"notice\":\"Sets data in batch for multiple `tokenId` and `dataKey` pairs.\"},\"setDataForTokenId(bytes32,bytes32,bytes)\":{\"notice\":\"Sets data for a specific `tokenId` and `dataKey`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interfaces/IShirts.sol\":\"IShirts\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\\n */\\ninterface IERC725Y is IERC165 {\\n    /**\\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\\n     * @param dataKey The data key for which to retrieve the value.\\n     * @return dataValue The bytes value stored under the specified data key.\\n     */\\n    function getData(\\n        bytes32 dataKey\\n    ) external view returns (bytes memory dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\\n     * @param dataKeys The array of keys which values to retrieve\\n     * @return dataValues The array of data stored at multiple keys\\n     */\\n    function getDataBatch(\\n        bytes32[] memory dataKeys\\n    ) external view returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\\n     *\\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\\n     * a fee mechanism for setting specific data.\\n     *\\n     * @param dataKey The data key for which to set a new value.\\n     * @param dataValue The new bytes value to set.\\n     */\\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\\n\\n    /**\\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\\n     *\\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\\n     *\\n     * @param dataKeys An array of data keys to set bytes values for.\\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\\n     */\\n    function setDataBatch(\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xa47c9e3eba0c733a1685b9fa309f753540c89ad2dca73236a2c953e7f5680e7b\",\"license\":\"CC0-1.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\\\";\\n\",\"keccak256\":\"0xf24c0f30ffdc2540755ae809effdba80029f8418e2b0c9f72b878aad50ba1b72\",\"license\":\"Apache-2.0\"},\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {\\n    IERC725Y\\n} from \\\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\\\";\\n\\n/**\\n * @title Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.\\n */\\ninterface ILSP8IdentifiableDigitalAsset is IERC165, IERC725Y {\\n    // --- Events\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from the `from` to the `to` address.\\n     * @param operator The address of operator that sent the `tokenId`\\n     * @param from The previous owner of the `tokenId`\\n     * @param to The new owner of `tokenId`\\n     * @param tokenId The tokenId that was transferred\\n     * @param force If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\\n     * @param data Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\\n     */\\n    event Transfer(\\n        address operator,\\n        address indexed from,\\n        address indexed to,\\n        bytes32 indexed tokenId,\\n        bool force,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\\n     * @param operator The address authorized as an operator.\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` address has access on behalf of `tokenOwner`.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorAuthorizationChanged(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\\n     * @param operator The address revoked from the operator array ({getOperatorsOf}).\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notified Bool indicating whether the operator has been notified or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorRevoked(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bool notified,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when setting data for `tokenId`.\\n     * @param tokenId The tokenId which data is set for.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event TokenIdDataChanged(\\n        bytes32 indexed tokenId,\\n        bytes32 indexed dataKey,\\n        bytes dataValue\\n    );\\n\\n    // --- Token queries\\n\\n    /**\\n     * @dev Returns the number of existing tokens that have been minted in this contract.\\n     * @return The number of existing tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // --- Token owner queries\\n\\n    /**\\n     * @dev Get the number of token IDs owned by `tokenOwner`.\\n\\n     * @param tokenOwner The address to query     *\\n     * @return The total number of token IDs that `tokenOwner` owns.\\n     */\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the address that owns a given `tokenId`.\\n     *\\n     * @param tokenId The token ID to query the owner for.\\n     * @return The owner address of the given `tokenId`.\\n     *\\n     * @custom:requirements `tokenId` must exist.\\n     * @custom:info if the `tokenId` is not owned by any address, the returned address will be `address(0)`\\n     */\\n    function tokenOwnerOf(bytes32 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Returns the list of token IDs that the `tokenOwner` address owns.\\n     * @param tokenOwner The address that we want to get the list of token IDs for.\\n     * @return An array of `bytes32[] tokenIds` owned by `tokenOwner`.\\n     */\\n    function tokenIdsOf(\\n        address tokenOwner\\n    ) external view returns (bytes32[] memory);\\n\\n    // --- TokenId Metadata functionality\\n\\n    /**\\n     * @notice Retrieves data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to retrieve.\\n     * @return dataValues The data value associated with the given `tokenId` and `dataKey`.\\n     */\\n    function getDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey\\n    ) external returns (bytes memory dataValues);\\n\\n    /**\\n     * @notice Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @return dataValues An array of data values for each pair of `tokenId` and `dataKey`.\\n     */\\n    function getDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys\\n    ) external returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Sets data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to set.\\n     * @param dataValue The value to set for the given data key.\\n     * @custom:events {TokenIdDataChanged} event.\\n     */\\n    function setDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey,\\n        bytes memory dataValue\\n    ) external;\\n\\n    /**\\n     * @notice Sets data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @param dataValues An array of values to set for the given data keys.\\n     * @custom:events {TokenIdDataChanged} event for each pair.\\n     */\\n    function setDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external;\\n\\n    // --- Operator functionality\\n\\n    /**\\n     * @dev Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}.\\n     * Notify the operator based on the LSP1-UniversalReceiver standard\\n     *\\n     * @param operator The address to authorize as an operator.\\n     * @param tokenId The token ID operator has access to.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller MUST be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorAuthorizationChanged} event.\\n     */\\n    function authorizeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner.\\n     * See also {isOperatorFor}.\\n     *\\n     * @param operator The address to revoke as an operator.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notify Boolean indicating whether to notify the operator or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\\n     */\\n    function revokeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bool notify,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Returns whether `operator` address is an operator for a given `tokenId`.\\n     *\\n     * @param operator The address to query operator status for.\\n     * @param tokenId The token ID to check if `operator` is allowed to operate on.\\n     *\\n     * @return `true` if `operator` is an operator for `tokenId`, `false` otherwise.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the current {tokenOwnerOf} `tokenId`.\\n     *\\n     * @custom:info The tokenOwner is its own operator.\\n     */\\n    function isOperatorFor(\\n        address operator,\\n        bytes32 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\\n     *\\n     * @param tokenId The token ID to get the operators for.\\n     * @return An array of operators allowed to transfer or burn a specific `tokenId`.\\n     *\\n     * Requirements\\n     * - `tokenId` must exist.\\n     */\\n    function getOperatorsOf(\\n        bytes32 tokenId\\n    ) external view returns (address[] memory);\\n\\n    // --- Transfer functionality\\n\\n    /**\\n     * @dev Transfer a given `tokenId` token from the `from` address to the `to` address.\\n     *\\n     * If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred.\\n     *\\n     * The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 standard.\\n     *\\n     * @param from The address that owns the given `tokenId`.\\n     * @param to The address that will receive the `tokenId`.\\n     * @param tokenId The token ID to transfer.\\n     * @param force When set to `true`, the `to` address CAN be any addres.\\n     * When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\\n     *\\n     * @custom:requirements\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself).\\n     * - `from` must own the given `tokenId`.\\n     * - If the caller is not `from`, it must be an operator for the `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} event when the `tokenId` is successfully transferred.\\n     *\\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\\n     *\\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\\n     *\\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\\n     * This even if the `force` was set to `true`.\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        bytes32 tokenId,\\n        bool force,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`.\\n     * If any transfer fails, the whole call will revert.\\n     *\\n     * @param from An array of sending addresses.\\n     * @param to An array of recipient addresses.\\n     * @param tokenId An array of token IDs to transfer.\\n     * @param force When set to `true`, `to` may be any address.\\n     * When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\\n     *\\n     *\\n     * @custom:requirements\\n     * - The arrays of `from`, `to` and `tokenId` must have the same length.\\n     * - no values in the `from` array can be the zero address.\\n     * - no values in the `to` array can be the zero address.\\n     * - `from` and `to` cannot be the same address at the same index on each arrays.\\n     * - each `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be an operator of each `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} events on each successful token transfer.\\n     */\\n    function transferBatch(\\n        address[] memory from,\\n        address[] memory to,\\n        bytes32[] memory tokenId,\\n        bool[] memory force,\\n        bytes[] memory data\\n    ) external;\\n\\n    /**\\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\\n     *\\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\\n     * @param data An array of ABI encoded function calls to be called on the contract.\\n     * @return results An array of abi-encoded data returned by the functions executed.\\n     */\\n    function batchCalls(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x16dccaeb35168c4e61763a2c35b075eeed7505661b10fc9c16194af6eb3751ad\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/interfaces/IShirts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ILSP8IdentifiableDigitalAsset as ILSP8} from \\\"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\\\";\\ninterface IShirts is ILSP8 {\\n    event ShirtsMinted(address _recipient, uint256 _amount);\\n\\n    function mint(\\n        address _recipient,\\n        uint256 _amount\\n    ) external payable;\\n    \\n    function getPrizePool() external view returns (address prizePool);\\n\\n    function getPrice() external view returns (uint256 price);\\n}\",\"keccak256\":\"0x4e3bf68e661345d6da97b438b69e498842a75f160579b20c32306eb755407a0e\",\"license\":\"MIT\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"events":{"DataChanged(bytes32,bytes)":{"notice":"The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`."}},"kind":"user","methods":{"batchCalls(bytes[])":{"notice":"Executing the following batch of abi-encoded function calls on the contract: `data`."},"getData(bytes32)":{"notice":"Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`."},"getDataBatch(bytes32[])":{"notice":"Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`."},"getDataBatchForTokenIds(bytes32[],bytes32[])":{"notice":"Retrieves data in batch for multiple `tokenId` and `dataKey` pairs."},"getDataForTokenId(bytes32,bytes32)":{"notice":"Retrieves data for a specific `tokenId` and `dataKey`."},"setData(bytes32,bytes)":{"notice":"Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`."},"setDataBatch(bytes32[],bytes[])":{"notice":"Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`."},"setDataBatchForTokenIds(bytes32[],bytes32[],bytes[])":{"notice":"Sets data in batch for multiple `tokenId` and `dataKey` pairs."},"setDataForTokenId(bytes32,bytes32,bytes)":{"notice":"Sets data for a specific `tokenId` and `dataKey`."}},"version":1}}},"contracts/mocks/UPMock.sol":{"BPunX":{"abi":[{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"payable","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"deployedBytecode":{"functionDebugData":{},"generatedSources":[],"immutableReferences":{},"linkReferences":{},"object":"","opcodes":"","sourceMap":""},"gasEstimates":null,"methodIdentifiers":{"mint(uint256)":"a0712d68"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/mocks/UPMock.sol\":\"BPunX\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\\n */\\ninterface IERC725Y is IERC165 {\\n    /**\\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\\n     * @param dataKey The data key for which to retrieve the value.\\n     * @return dataValue The bytes value stored under the specified data key.\\n     */\\n    function getData(\\n        bytes32 dataKey\\n    ) external view returns (bytes memory dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\\n     * @param dataKeys The array of keys which values to retrieve\\n     * @return dataValues The array of data stored at multiple keys\\n     */\\n    function getDataBatch(\\n        bytes32[] memory dataKeys\\n    ) external view returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\\n     *\\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\\n     * a fee mechanism for setting specific data.\\n     *\\n     * @param dataKey The data key for which to set a new value.\\n     * @param dataValue The new bytes value to set.\\n     */\\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\\n\\n    /**\\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\\n     *\\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\\n     *\\n     * @param dataKeys An array of data keys to set bytes values for.\\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\\n     */\\n    function setDataBatch(\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xa47c9e3eba0c733a1685b9fa309f753540c89ad2dca73236a2c953e7f5680e7b\",\"license\":\"CC0-1.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp0-contracts/contracts/LSP0Constants.sol\\\";\\n\",\"keccak256\":\"0x82f1c5d5689df750d081fef3b0d48faca2f13f4b2b6b67426deb9da1060dc3db\",\"license\":\"Apache-2.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\\\";\\n\",\"keccak256\":\"0x39114a8dc3ec9c8ddd22cb0219614aa82565fe8338acfbd99cdb7c9ad55b1d1c\",\"license\":\"Apache-2.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp1-contracts/contracts/LSP1Constants.sol\\\";\\n\",\"keccak256\":\"0x2fbc59802e5ab01aeb72fdc69fca1bbb420eeeb1c4bc009a1e2a7b78b491999d\",\"license\":\"Apache-2.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\\\";\\n\",\"keccak256\":\"0xf24c0f30ffdc2540755ae809effdba80029f8418e2b0c9f72b878aad50ba1b72\",\"license\":\"Apache-2.0\"},\"@lukso/lsp0-contracts/contracts/LSP0Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// --- ERC165 interface ids\\nbytes4 constant _INTERFACEID_LSP0 = 0x24871b3d;\\nbytes4 constant _INTERFACEID_ERC1271 = 0x1626ba7e;\\n\\n// ERC1271 - Standard Signature Validation\\nbytes4 constant _ERC1271_SUCCESSVALUE = 0x1626ba7e;\\nbytes4 constant _ERC1271_FAILVALUE = 0xffffffff;\\n\\n// --- Native Token Type Id\\n\\n// keccak256('LSP0ValueReceived')\\nbytes32 constant _TYPEID_LSP0_VALUE_RECEIVED = 0x9c4705229491d365fb5434052e12a386d6771d976bea61070a8c694e8affea3d;\\n\\n// Ownership Transfer Type IDs\\n\\n// keccak256('LSP0OwnershipTransferStarted')\\nbytes32 constant _TYPEID_LSP0_OwnershipTransferStarted = 0xe17117c9d2665d1dbeb479ed8058bbebde3c50ac50e2e65619f60006caac6926;\\n\\n// keccak256('LSP0OwnershipTransferred_SenderNotification')\\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_SenderNotification = 0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814;\\n\\n// keccak256('LSP0OwnershipTransferred_RecipientNotification')\\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_RecipientNotification = 0xceca317f109c43507871523e82dc2a3cc64dfa18f12da0b6db14f6e23f995538;\\n\",\"keccak256\":\"0x9066f85dcef006b7896a367fd08fd0a62706a32457be6859191f15f5e865d049\",\"license\":\"Apache-2.0\"},\"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.\\n * @dev LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received.\\n */\\ninterface ILSP1UniversalReceiver {\\n    /**\\n     * @dev Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\\n     * @notice Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\\n     *\\n     * @param from The address of the EOA or smart contract that called the {universalReceiver(...)} function.\\n     * @param value The amount sent to the {universalReceiver(...)} function.\\n     * @param typeId A `bytes32` unique identifier (= _\\\"hook\\\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\\n     * @param receivedData Any arbitrary data that was sent to the {universalReceiver(...)} function.\\n     * @param returnedValue The value returned by the {universalReceiver(...)} function.\\n     */\\n    event UniversalReceiver(\\n        address indexed from,\\n        uint256 indexed value,\\n        bytes32 indexed typeId,\\n        bytes receivedData,\\n        bytes returnedValue\\n    );\\n\\n    /**\\n     * @dev Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\\n     * @notice Reacted on received notification with `typeId` & `data`.\\n     *\\n     * @param typeId The hash of a specific standard or a hook.\\n     * @param data The arbitrary data received with the call.\\n     *\\n     * @custom:events {UniversalReceiver} event.\\n     */\\n    function universalReceiver(\\n        bytes32 typeId,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5b8764a678dc9d6673eafa8ad0ee6053cdea30acb58015bdf9c93f9f1788b49b\",\"license\":\"Apache-2.0\"},\"@lukso/lsp1-contracts/contracts/LSP1Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// --- ERC165 interface ids\\nbytes4 constant _INTERFACEID_LSP1 = 0x6bb56a14;\\nbytes4 constant _INTERFACEID_LSP1_DELEGATE = 0xa245bbda;\\n\\n// --- ERC725Y Data Keys\\n\\n// bytes10(keccak256('LSP1UniversalReceiverDelegate'))\\nbytes10 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX = 0x0cfc51aec37c55a4d0b1;\\n\\n// keccak256('LSP1UniversalReceiverDelegate')\\nbytes32 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY = 0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47;\\n\",\"keccak256\":\"0x0f87fc38243fc70316e22814f5a79d9c0770a39f64077cbc6fb5fddfa1d4c23c\",\"license\":\"Apache-2.0\"},\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {\\n    IERC725Y\\n} from \\\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\\\";\\n\\n/**\\n * @title Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.\\n */\\ninterface ILSP8IdentifiableDigitalAsset is IERC165, IERC725Y {\\n    // --- Events\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from the `from` to the `to` address.\\n     * @param operator The address of operator that sent the `tokenId`\\n     * @param from The previous owner of the `tokenId`\\n     * @param to The new owner of `tokenId`\\n     * @param tokenId The tokenId that was transferred\\n     * @param force If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\\n     * @param data Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\\n     */\\n    event Transfer(\\n        address operator,\\n        address indexed from,\\n        address indexed to,\\n        bytes32 indexed tokenId,\\n        bool force,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\\n     * @param operator The address authorized as an operator.\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` address has access on behalf of `tokenOwner`.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorAuthorizationChanged(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\\n     * @param operator The address revoked from the operator array ({getOperatorsOf}).\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notified Bool indicating whether the operator has been notified or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorRevoked(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bool notified,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when setting data for `tokenId`.\\n     * @param tokenId The tokenId which data is set for.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event TokenIdDataChanged(\\n        bytes32 indexed tokenId,\\n        bytes32 indexed dataKey,\\n        bytes dataValue\\n    );\\n\\n    // --- Token queries\\n\\n    /**\\n     * @dev Returns the number of existing tokens that have been minted in this contract.\\n     * @return The number of existing tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // --- Token owner queries\\n\\n    /**\\n     * @dev Get the number of token IDs owned by `tokenOwner`.\\n\\n     * @param tokenOwner The address to query     *\\n     * @return The total number of token IDs that `tokenOwner` owns.\\n     */\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the address that owns a given `tokenId`.\\n     *\\n     * @param tokenId The token ID to query the owner for.\\n     * @return The owner address of the given `tokenId`.\\n     *\\n     * @custom:requirements `tokenId` must exist.\\n     * @custom:info if the `tokenId` is not owned by any address, the returned address will be `address(0)`\\n     */\\n    function tokenOwnerOf(bytes32 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Returns the list of token IDs that the `tokenOwner` address owns.\\n     * @param tokenOwner The address that we want to get the list of token IDs for.\\n     * @return An array of `bytes32[] tokenIds` owned by `tokenOwner`.\\n     */\\n    function tokenIdsOf(\\n        address tokenOwner\\n    ) external view returns (bytes32[] memory);\\n\\n    // --- TokenId Metadata functionality\\n\\n    /**\\n     * @notice Retrieves data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to retrieve.\\n     * @return dataValues The data value associated with the given `tokenId` and `dataKey`.\\n     */\\n    function getDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey\\n    ) external returns (bytes memory dataValues);\\n\\n    /**\\n     * @notice Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @return dataValues An array of data values for each pair of `tokenId` and `dataKey`.\\n     */\\n    function getDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys\\n    ) external returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Sets data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to set.\\n     * @param dataValue The value to set for the given data key.\\n     * @custom:events {TokenIdDataChanged} event.\\n     */\\n    function setDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey,\\n        bytes memory dataValue\\n    ) external;\\n\\n    /**\\n     * @notice Sets data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @param dataValues An array of values to set for the given data keys.\\n     * @custom:events {TokenIdDataChanged} event for each pair.\\n     */\\n    function setDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external;\\n\\n    // --- Operator functionality\\n\\n    /**\\n     * @dev Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}.\\n     * Notify the operator based on the LSP1-UniversalReceiver standard\\n     *\\n     * @param operator The address to authorize as an operator.\\n     * @param tokenId The token ID operator has access to.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller MUST be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorAuthorizationChanged} event.\\n     */\\n    function authorizeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner.\\n     * See also {isOperatorFor}.\\n     *\\n     * @param operator The address to revoke as an operator.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notify Boolean indicating whether to notify the operator or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\\n     */\\n    function revokeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bool notify,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Returns whether `operator` address is an operator for a given `tokenId`.\\n     *\\n     * @param operator The address to query operator status for.\\n     * @param tokenId The token ID to check if `operator` is allowed to operate on.\\n     *\\n     * @return `true` if `operator` is an operator for `tokenId`, `false` otherwise.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the current {tokenOwnerOf} `tokenId`.\\n     *\\n     * @custom:info The tokenOwner is its own operator.\\n     */\\n    function isOperatorFor(\\n        address operator,\\n        bytes32 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\\n     *\\n     * @param tokenId The token ID to get the operators for.\\n     * @return An array of operators allowed to transfer or burn a specific `tokenId`.\\n     *\\n     * Requirements\\n     * - `tokenId` must exist.\\n     */\\n    function getOperatorsOf(\\n        bytes32 tokenId\\n    ) external view returns (address[] memory);\\n\\n    // --- Transfer functionality\\n\\n    /**\\n     * @dev Transfer a given `tokenId` token from the `from` address to the `to` address.\\n     *\\n     * If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred.\\n     *\\n     * The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 standard.\\n     *\\n     * @param from The address that owns the given `tokenId`.\\n     * @param to The address that will receive the `tokenId`.\\n     * @param tokenId The token ID to transfer.\\n     * @param force When set to `true`, the `to` address CAN be any addres.\\n     * When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\\n     *\\n     * @custom:requirements\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself).\\n     * - `from` must own the given `tokenId`.\\n     * - If the caller is not `from`, it must be an operator for the `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} event when the `tokenId` is successfully transferred.\\n     *\\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\\n     *\\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\\n     *\\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\\n     * This even if the `force` was set to `true`.\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        bytes32 tokenId,\\n        bool force,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`.\\n     * If any transfer fails, the whole call will revert.\\n     *\\n     * @param from An array of sending addresses.\\n     * @param to An array of recipient addresses.\\n     * @param tokenId An array of token IDs to transfer.\\n     * @param force When set to `true`, `to` may be any address.\\n     * When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\\n     *\\n     *\\n     * @custom:requirements\\n     * - The arrays of `from`, `to` and `tokenId` must have the same length.\\n     * - no values in the `from` array can be the zero address.\\n     * - no values in the `to` array can be the zero address.\\n     * - `from` and `to` cannot be the same address at the same index on each arrays.\\n     * - each `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be an operator of each `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} events on each successful token transfer.\\n     */\\n    function transferBatch(\\n        address[] memory from,\\n        address[] memory to,\\n        bytes32[] memory tokenId,\\n        bool[] memory force,\\n        bytes[] memory data\\n    ) external;\\n\\n    /**\\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\\n     *\\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\\n     * @param data An array of ABI encoded function calls to be called on the contract.\\n     * @return results An array of abi-encoded data returned by the functions executed.\\n     */\\n    function batchCalls(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x16dccaeb35168c4e61763a2c35b075eeed7505661b10fc9c16194af6eb3751ad\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/interfaces/IShirts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ILSP8IdentifiableDigitalAsset as ILSP8} from \\\"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\\\";\\ninterface IShirts is ILSP8 {\\n    event ShirtsMinted(address _recipient, uint256 _amount);\\n\\n    function mint(\\n        address _recipient,\\n        uint256 _amount\\n    ) external payable;\\n    \\n    function getPrizePool() external view returns (address prizePool);\\n\\n    function getPrice() external view returns (uint256 price);\\n}\",\"keccak256\":\"0x4e3bf68e661345d6da97b438b69e498842a75f160579b20c32306eb755407a0e\",\"license\":\"MIT\"},\"contracts/mocks/UPMock.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// interfaces\\nimport {\\n    ILSP1UniversalReceiver\\n} from \\\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\\\";\\n\\n// modules\\nimport {\\n    ERC165\\n} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n// constants\\nimport {_INTERFACEID_LSP1} from \\\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol\\\";\\nimport {_INTERFACEID_LSP0} from \\\"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol\\\";\\n\\nimport {IShirts} from \\\"../interfaces/IShirts.sol\\\";\\n\\ninterface BPunX {\\n    function mint(uint256 _amount) external payable;\\n}\\ncontract UPMock is ERC165, ILSP1UniversalReceiver {\\n    \\n    /// override the supportsInterface function from ERC165\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == _INTERFACEID_LSP1 ||\\n            interfaceId == _INTERFACEID_LSP0 ||\\n            super.supportsInterface(interfaceId);\\n    }\\n    function universalReceiver(\\n        bytes32 typeId,\\n        bytes memory data\\n    ) external payable override returns (bytes memory returnValue) {\\n        emit UniversalReceiver(msg.sender, msg.value, typeId, data, \\\"\\\");\\n\\n        return \\\"thanks for calling\\\";\\n    }\\n    /**\\n     * @notice Verifies that the signer is the owner of the signing contract.\\n     */\\n    function isValidSignature(\\n        bytes32 /* messageHash */,\\n        bytes calldata /* signature */\\n    ) external pure returns (bytes4) {\\n        // always return true (just for testing)\\n        return 0x1626ba7e;\\n    }\\n    function transfer(\\n        address shirts,\\n        address from,\\n        address to,\\n        bytes32 tokenId,\\n        bool force,\\n        bytes memory data\\n    ) external {\\n        IShirts(shirts).transfer(from, to, tokenId, force, data);\\n    }\\n    function fund() external payable {}\\n    function getBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n    receive() external payable {}\\n    fallback() external payable {}\\n}\",\"keccak256\":\"0xde0394b28362567783cd1a4ec10640ac33a81440f2a80bfa611f5b5f08be635c\",\"license\":\"Apache-2.0\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"kind":"user","methods":{},"version":1}},"UPMock":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"uint256","name":"value","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"typeId","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"receivedData","type":"bytes"},{"indexed":false,"internalType":"bytes","name":"returnedValue","type":"bytes"}],"name":"UniversalReceiver","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[],"name":"fund","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[],"name":"getBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"","type":"bytes32"},{"internalType":"bytes","name":"","type":"bytes"}],"name":"isValidSignature","outputs":[{"internalType":"bytes4","name":"","type":"bytes4"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"shirts","type":"address"},{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bytes32","name":"tokenId","type":"bytes32"},{"internalType":"bool","name":"force","type":"bool"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"transfer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"typeId","type":"bytes32"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"universalReceiver","outputs":[{"internalType":"bytes","name":"returnValue","type":"bytes"}],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}],"devdoc":{"events":{"UniversalReceiver(address,uint256,bytes32,bytes,bytes)":{"details":"Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`","params":{"from":"The address of the EOA or smart contract that called the {universalReceiver(...)} function.","receivedData":"Any arbitrary data that was sent to the {universalReceiver(...)} function.","returnedValue":"The value returned by the {universalReceiver(...)} function.","typeId":"A `bytes32` unique identifier (= _\"hook\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.","value":"The amount sent to the {universalReceiver(...)} function."}}},"kind":"dev","methods":{"universalReceiver(bytes32,bytes)":{"details":"Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.","params":{"data":"The arbitrary data received with the call.","typeId":"The hash of a specific standard or a hook."}}},"version":1},"evm":{"bytecode":{"functionDebugData":{},"generatedSources":[],"linkReferences":{},"object":"608060405234801561001057600080fd5b506105a8806100206000396000f3fe6080604052600436106100565760003560e01c806301ffc9a71461005f57806312065fe0146100945780631626ba7e146100af5780636bb56a14146100f2578063876e93fe14610112578063b60d42881461005d57005b3661005d57005b005b34801561006b57600080fd5b5061007f61007a366004610267565b610132565b60405190151581526020015b60405180910390f35b3480156100a057600080fd5b5060405147815260200161008b565b3480156100bb57600080fd5b506100d96100ca366004610298565b630b135d3f60e11b9392505050565b6040516001600160e01b0319909116815260200161008b565b6101056101003660046103b7565b610184565b60405161008b9190610444565b34801561011e57600080fd5b5061005d61012d366004610473565b6101f9565b60006001600160e01b03198216631aed5a8560e21b148061016357506001600160e01b031982166324871b3d60e01b145b8061017e57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60608234336001600160a01b03167f9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2856040516101c19190610502565b60405180910390a4506040805180820190915260128152717468616e6b7320666f722063616c6c696e6760701b602082015292915050565b60405163288db4a960e11b81526001600160a01b0387169063511b69529061022d908890889088908890889060040161052c565b600060405180830381600087803b15801561024757600080fd5b505af115801561025b573d6000803e3d6000fd5b50505050505050505050565b60006020828403121561027957600080fd5b81356001600160e01b03198116811461029157600080fd5b9392505050565b6000806000604084860312156102ad57600080fd5b83359250602084013567ffffffffffffffff808211156102cc57600080fd5b818601915086601f8301126102e057600080fd5b8135818111156102ef57600080fd5b87602082850101111561030157600080fd5b6020830194508093505050509250925092565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261033b57600080fd5b813567ffffffffffffffff8082111561035657610356610314565b604051601f8301601f19908116603f0116810190828211818310171561037e5761037e610314565b8160405283815286602085880101111561039757600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080604083850312156103ca57600080fd5b82359150602083013567ffffffffffffffff8111156103e857600080fd5b6103f48582860161032a565b9150509250929050565b6000815180845260005b8181101561042457602081850181015186830182015201610408565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061029160208301846103fe565b80356001600160a01b038116811461046e57600080fd5b919050565b60008060008060008060c0878903121561048c57600080fd5b61049587610457565b95506104a360208801610457565b94506104b160408801610457565b935060608701359250608087013580151581146104cd57600080fd5b915060a087013567ffffffffffffffff8111156104e957600080fd5b6104f589828a0161032a565b9150509295509295509295565b60408152600061051560408301846103fe565b828103602093840152600081529190910192915050565b6001600160a01b0386811682528516602082015260408101849052821515606082015260a060808201819052600090610567908301846103fe565b97965050505050505056fea2646970667358221220e15eeaadee6d8f52262118cba70aea5892b939de7f4493effd8e9223da481c1c64736f6c63430008140033","opcodes":"PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x5A8 DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x56 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x1FFC9A7 EQ PUSH2 0x5F JUMPI DUP1 PUSH4 0x12065FE0 EQ PUSH2 0x94 JUMPI DUP1 PUSH4 0x1626BA7E EQ PUSH2 0xAF JUMPI DUP1 PUSH4 0x6BB56A14 EQ PUSH2 0xF2 JUMPI DUP1 PUSH4 0x876E93FE EQ PUSH2 0x112 JUMPI DUP1 PUSH4 0xB60D4288 EQ PUSH2 0x5D JUMPI STOP JUMPDEST CALLDATASIZE PUSH2 0x5D JUMPI STOP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x6B JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x7F PUSH2 0x7A CALLDATASIZE PUSH1 0x4 PUSH2 0x267 JUMP JUMPDEST PUSH2 0x132 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xA0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD SELFBALANCE DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0x8B JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xBB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xD9 PUSH2 0xCA CALLDATASIZE PUSH1 0x4 PUSH2 0x298 JUMP JUMPDEST PUSH4 0xB135D3F PUSH1 0xE1 SHL SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0x8B JUMP JUMPDEST PUSH2 0x105 PUSH2 0x100 CALLDATASIZE PUSH1 0x4 PUSH2 0x3B7 JUMP JUMPDEST PUSH2 0x184 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x8B SWAP2 SWAP1 PUSH2 0x444 JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x11E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x5D PUSH2 0x12D CALLDATASIZE PUSH1 0x4 PUSH2 0x473 JUMP JUMPDEST PUSH2 0x1F9 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP3 AND PUSH4 0x1AED5A85 PUSH1 0xE2 SHL EQ DUP1 PUSH2 0x163 JUMPI POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP3 AND PUSH4 0x24871B3D PUSH1 0xE0 SHL EQ JUMPDEST DUP1 PUSH2 0x17E JUMPI POP PUSH4 0x1FFC9A7 PUSH1 0xE0 SHL PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP4 AND EQ JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x60 DUP3 CALLVALUE CALLER PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH32 0x9C3BA68EB5742B8E3961AEA0AFC7371A71BF433C8A67A831803B64C064A178C2 DUP6 PUSH1 0x40 MLOAD PUSH2 0x1C1 SWAP2 SWAP1 PUSH2 0x502 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG4 POP PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x12 DUP2 MSTORE PUSH18 0x7468616E6B7320666F722063616C6C696E67 PUSH1 0x70 SHL PUSH1 0x20 DUP3 ADD MSTORE SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x288DB4A9 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP8 AND SWAP1 PUSH4 0x511B6952 SWAP1 PUSH2 0x22D SWAP1 DUP9 SWAP1 DUP9 SWAP1 DUP9 SWAP1 DUP9 SWAP1 DUP9 SWAP1 PUSH1 0x4 ADD PUSH2 0x52C JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x247 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x25B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x279 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP2 AND DUP2 EQ PUSH2 0x291 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x40 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x2AD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 CALLDATALOAD SWAP3 POP PUSH1 0x20 DUP5 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x2CC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP7 ADD SWAP2 POP DUP7 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x2E0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0x2EF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP8 PUSH1 0x20 DUP3 DUP6 ADD ADD GT ISZERO PUSH2 0x301 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x20 DUP4 ADD SWAP5 POP DUP1 SWAP4 POP POP POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 DUP3 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x33B JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x356 JUMPI PUSH2 0x356 PUSH2 0x314 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1F DUP4 ADD PUSH1 0x1F NOT SWAP1 DUP2 AND PUSH1 0x3F ADD AND DUP2 ADD SWAP1 DUP3 DUP3 GT DUP2 DUP4 LT OR ISZERO PUSH2 0x37E JUMPI PUSH2 0x37E PUSH2 0x314 JUMP JUMPDEST DUP2 PUSH1 0x40 MSTORE DUP4 DUP2 MSTORE DUP7 PUSH1 0x20 DUP6 DUP9 ADD ADD GT ISZERO PUSH2 0x397 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 PUSH1 0x20 DUP8 ADD PUSH1 0x20 DUP4 ADD CALLDATACOPY PUSH1 0x0 PUSH1 0x20 DUP6 DUP4 ADD ADD MSTORE DUP1 SWAP5 POP POP POP POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0x3CA JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 CALLDATALOAD SWAP2 POP PUSH1 0x20 DUP4 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x3E8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x3F4 DUP6 DUP3 DUP7 ADD PUSH2 0x32A JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0x424 JUMPI PUSH1 0x20 DUP2 DUP6 ADD DUP2 ADD MLOAD DUP7 DUP4 ADD DUP3 ADD MSTORE ADD PUSH2 0x408 JUMP JUMPDEST POP PUSH1 0x0 PUSH1 0x20 DUP3 DUP7 ADD ADD MSTORE PUSH1 0x20 PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND DUP6 ADD ADD SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE PUSH1 0x0 PUSH2 0x291 PUSH1 0x20 DUP4 ADD DUP5 PUSH2 0x3FE JUMP JUMPDEST DUP1 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x46E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0xC0 DUP8 DUP10 SUB SLT ISZERO PUSH2 0x48C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x495 DUP8 PUSH2 0x457 JUMP JUMPDEST SWAP6 POP PUSH2 0x4A3 PUSH1 0x20 DUP9 ADD PUSH2 0x457 JUMP JUMPDEST SWAP5 POP PUSH2 0x4B1 PUSH1 0x40 DUP9 ADD PUSH2 0x457 JUMP JUMPDEST SWAP4 POP PUSH1 0x60 DUP8 ADD CALLDATALOAD SWAP3 POP PUSH1 0x80 DUP8 ADD CALLDATALOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0x4CD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 POP PUSH1 0xA0 DUP8 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x4E9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x4F5 DUP10 DUP3 DUP11 ADD PUSH2 0x32A JUMP JUMPDEST SWAP2 POP POP SWAP3 SWAP6 POP SWAP3 SWAP6 POP SWAP3 SWAP6 JUMP JUMPDEST PUSH1 0x40 DUP2 MSTORE PUSH1 0x0 PUSH2 0x515 PUSH1 0x40 DUP4 ADD DUP5 PUSH2 0x3FE JUMP JUMPDEST DUP3 DUP2 SUB PUSH1 0x20 SWAP4 DUP5 ADD MSTORE PUSH1 0x0 DUP2 MSTORE SWAP2 SWAP1 SWAP2 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP7 DUP2 AND DUP3 MSTORE DUP6 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x40 DUP2 ADD DUP5 SWAP1 MSTORE DUP3 ISZERO ISZERO PUSH1 0x60 DUP3 ADD MSTORE PUSH1 0xA0 PUSH1 0x80 DUP3 ADD DUP2 SWAP1 MSTORE PUSH1 0x0 SWAP1 PUSH2 0x567 SWAP1 DUP4 ADD DUP5 PUSH2 0x3FE JUMP JUMPDEST SWAP8 SWAP7 POP POP POP POP POP POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xE1 0x5E 0xEA 0xAD 0xEE PUSH14 0x8F52262118CBA70AEA5892B939DE PUSH32 0x4493EFFD8E9223DA481C1C64736F6C6343000814003300000000000000000000 ","sourceMap":"667:1476:12:-:0;;;;;;;;;;;;;;;;;;;"},"deployedBytecode":{"functionDebugData":{"@_544":{"entryPoint":null,"id":544,"parameterSlots":0,"returnSlots":0},"@_548":{"entryPoint":null,"id":548,"parameterSlots":0,"returnSlots":0},"@fund_528":{"entryPoint":null,"id":528,"parameterSlots":0,"returnSlots":0},"@getBalance_540":{"entryPoint":null,"id":540,"parameterSlots":0,"returnSlots":1},"@isValidSignature_497":{"entryPoint":null,"id":497,"parameterSlots":3,"returnSlots":1},"@supportsInterface_373":{"entryPoint":null,"id":373,"parameterSlots":1,"returnSlots":1},"@supportsInterface_461":{"entryPoint":306,"id":461,"parameterSlots":1,"returnSlots":1},"@transfer_524":{"entryPoint":505,"id":524,"parameterSlots":6,"returnSlots":0},"@universalReceiver_484":{"entryPoint":388,"id":484,"parameterSlots":2,"returnSlots":1},"abi_decode_address":{"entryPoint":1111,"id":null,"parameterSlots":1,"returnSlots":1},"abi_decode_bytes":{"entryPoint":810,"id":null,"parameterSlots":2,"returnSlots":1},"abi_decode_tuple_t_addresst_addresst_addresst_bytes32t_boolt_bytes_memory_ptr":{"entryPoint":1139,"id":null,"parameterSlots":2,"returnSlots":6},"abi_decode_tuple_t_bytes32t_bytes_calldata_ptr":{"entryPoint":664,"id":null,"parameterSlots":2,"returnSlots":3},"abi_decode_tuple_t_bytes32t_bytes_memory_ptr":{"entryPoint":951,"id":null,"parameterSlots":2,"returnSlots":2},"abi_decode_tuple_t_bytes4":{"entryPoint":615,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_bytes":{"entryPoint":1022,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_address_t_address_t_bytes32_t_bool_t_bytes_memory_ptr__to_t_address_t_address_t_bytes32_t_bool_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1324,"id":null,"parameterSlots":6,"returnSlots":1},"abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_bytes4__to_t_bytes4__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1092,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_bytes_memory_ptr_t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470__to_t_bytes_memory_ptr_t_bytes_memory_ptr__fromStack_reversed":{"entryPoint":1282,"id":null,"parameterSlots":2,"returnSlots":1},"abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed":{"entryPoint":null,"id":null,"parameterSlots":2,"returnSlots":1},"panic_error_0x41":{"entryPoint":788,"id":null,"parameterSlots":0,"returnSlots":0}},"generatedSources":[{"ast":{"nodeType":"YulBlock","src":"0:5421:13","statements":[{"nodeType":"YulBlock","src":"6:3:13","statements":[]},{"body":{"nodeType":"YulBlock","src":"83:217:13","statements":[{"body":{"nodeType":"YulBlock","src":"129:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"138:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"141:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"131:6:13"},"nodeType":"YulFunctionCall","src":"131:12:13"},"nodeType":"YulExpressionStatement","src":"131:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"104:7:13"},{"name":"headStart","nodeType":"YulIdentifier","src":"113:9:13"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"100:3:13"},"nodeType":"YulFunctionCall","src":"100:23:13"},{"kind":"number","nodeType":"YulLiteral","src":"125:2:13","type":"","value":"32"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"96:3:13"},"nodeType":"YulFunctionCall","src":"96:32:13"},"nodeType":"YulIf","src":"93:52:13"},{"nodeType":"YulVariableDeclaration","src":"154:36:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"180:9:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"167:12:13"},"nodeType":"YulFunctionCall","src":"167:23:13"},"variables":[{"name":"value","nodeType":"YulTypedName","src":"158:5:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"254:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"263:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"266:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"256:6:13"},"nodeType":"YulFunctionCall","src":"256:12:13"},"nodeType":"YulExpressionStatement","src":"256:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"212:5:13"},{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"223:5:13"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"234:3:13","type":"","value":"224"},{"kind":"number","nodeType":"YulLiteral","src":"239:10:13","type":"","value":"0xffffffff"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"230:3:13"},"nodeType":"YulFunctionCall","src":"230:20:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"219:3:13"},"nodeType":"YulFunctionCall","src":"219:32:13"}],"functionName":{"name":"eq","nodeType":"YulIdentifier","src":"209:2:13"},"nodeType":"YulFunctionCall","src":"209:43:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"202:6:13"},"nodeType":"YulFunctionCall","src":"202:51:13"},"nodeType":"YulIf","src":"199:71:13"},{"nodeType":"YulAssignment","src":"279:15:13","value":{"name":"value","nodeType":"YulIdentifier","src":"289:5:13"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"279:6:13"}]}]},"name":"abi_decode_tuple_t_bytes4","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"49:9:13","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"60:7:13","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"72:6:13","type":""}],"src":"14:286:13"},{"body":{"nodeType":"YulBlock","src":"400:92:13","statements":[{"nodeType":"YulAssignment","src":"410:26:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"422:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"433:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"418:3:13"},"nodeType":"YulFunctionCall","src":"418:18:13"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"410:4:13"}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"452:9:13"},{"arguments":[{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"477:6:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"470:6:13"},"nodeType":"YulFunctionCall","src":"470:14:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"463:6:13"},"nodeType":"YulFunctionCall","src":"463:22:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"445:6:13"},"nodeType":"YulFunctionCall","src":"445:41:13"},"nodeType":"YulExpressionStatement","src":"445:41:13"}]},"name":"abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"369:9:13","type":""},{"name":"value0","nodeType":"YulTypedName","src":"380:6:13","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"391:4:13","type":""}],"src":"305:187:13"},{"body":{"nodeType":"YulBlock","src":"598:76:13","statements":[{"nodeType":"YulAssignment","src":"608:26:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"620:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"631:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"616:3:13"},"nodeType":"YulFunctionCall","src":"616:18:13"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"608:4:13"}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"650:9:13"},{"name":"value0","nodeType":"YulIdentifier","src":"661:6:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"643:6:13"},"nodeType":"YulFunctionCall","src":"643:25:13"},"nodeType":"YulExpressionStatement","src":"643:25:13"}]},"name":"abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"567:9:13","type":""},{"name":"value0","nodeType":"YulTypedName","src":"578:6:13","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"589:4:13","type":""}],"src":"497:177:13"},{"body":{"nodeType":"YulBlock","src":"785:553:13","statements":[{"body":{"nodeType":"YulBlock","src":"831:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"840:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"843:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"833:6:13"},"nodeType":"YulFunctionCall","src":"833:12:13"},"nodeType":"YulExpressionStatement","src":"833:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"806:7:13"},{"name":"headStart","nodeType":"YulIdentifier","src":"815:9:13"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"802:3:13"},"nodeType":"YulFunctionCall","src":"802:23:13"},{"kind":"number","nodeType":"YulLiteral","src":"827:2:13","type":"","value":"64"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"798:3:13"},"nodeType":"YulFunctionCall","src":"798:32:13"},"nodeType":"YulIf","src":"795:52:13"},{"nodeType":"YulAssignment","src":"856:33:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"879:9:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"866:12:13"},"nodeType":"YulFunctionCall","src":"866:23:13"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"856:6:13"}]},{"nodeType":"YulVariableDeclaration","src":"898:46:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"929:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"940:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"925:3:13"},"nodeType":"YulFunctionCall","src":"925:18:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"912:12:13"},"nodeType":"YulFunctionCall","src":"912:32:13"},"variables":[{"name":"offset","nodeType":"YulTypedName","src":"902:6:13","type":""}]},{"nodeType":"YulVariableDeclaration","src":"953:28:13","value":{"kind":"number","nodeType":"YulLiteral","src":"963:18:13","type":"","value":"0xffffffffffffffff"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"957:2:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"1008:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1017:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1020:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1010:6:13"},"nodeType":"YulFunctionCall","src":"1010:12:13"},"nodeType":"YulExpressionStatement","src":"1010:12:13"}]},"condition":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"996:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"1004:2:13"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"993:2:13"},"nodeType":"YulFunctionCall","src":"993:14:13"},"nodeType":"YulIf","src":"990:34:13"},{"nodeType":"YulVariableDeclaration","src":"1033:32:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1047:9:13"},{"name":"offset","nodeType":"YulIdentifier","src":"1058:6:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1043:3:13"},"nodeType":"YulFunctionCall","src":"1043:22:13"},"variables":[{"name":"_2","nodeType":"YulTypedName","src":"1037:2:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"1113:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1122:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1125:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1115:6:13"},"nodeType":"YulFunctionCall","src":"1115:12:13"},"nodeType":"YulExpressionStatement","src":"1115:12:13"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"1092:2:13"},{"kind":"number","nodeType":"YulLiteral","src":"1096:4:13","type":"","value":"0x1f"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1088:3:13"},"nodeType":"YulFunctionCall","src":"1088:13:13"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"1103:7:13"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"1084:3:13"},"nodeType":"YulFunctionCall","src":"1084:27:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"1077:6:13"},"nodeType":"YulFunctionCall","src":"1077:35:13"},"nodeType":"YulIf","src":"1074:55:13"},{"nodeType":"YulVariableDeclaration","src":"1138:30:13","value":{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"1165:2:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"1152:12:13"},"nodeType":"YulFunctionCall","src":"1152:16:13"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"1142:6:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"1195:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1204:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1207:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1197:6:13"},"nodeType":"YulFunctionCall","src":"1197:12:13"},"nodeType":"YulExpressionStatement","src":"1197:12:13"}]},"condition":{"arguments":[{"name":"length","nodeType":"YulIdentifier","src":"1183:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"1191:2:13"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"1180:2:13"},"nodeType":"YulFunctionCall","src":"1180:14:13"},"nodeType":"YulIf","src":"1177:34:13"},{"body":{"nodeType":"YulBlock","src":"1261:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1270:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1273:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1263:6:13"},"nodeType":"YulFunctionCall","src":"1263:12:13"},"nodeType":"YulExpressionStatement","src":"1263:12:13"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"1234:2:13"},{"name":"length","nodeType":"YulIdentifier","src":"1238:6:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1230:3:13"},"nodeType":"YulFunctionCall","src":"1230:15:13"},{"kind":"number","nodeType":"YulLiteral","src":"1247:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1226:3:13"},"nodeType":"YulFunctionCall","src":"1226:24:13"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"1252:7:13"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"1223:2:13"},"nodeType":"YulFunctionCall","src":"1223:37:13"},"nodeType":"YulIf","src":"1220:57:13"},{"nodeType":"YulAssignment","src":"1286:21:13","value":{"arguments":[{"name":"_2","nodeType":"YulIdentifier","src":"1300:2:13"},{"kind":"number","nodeType":"YulLiteral","src":"1304:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1296:3:13"},"nodeType":"YulFunctionCall","src":"1296:11:13"},"variableNames":[{"name":"value1","nodeType":"YulIdentifier","src":"1286:6:13"}]},{"nodeType":"YulAssignment","src":"1316:16:13","value":{"name":"length","nodeType":"YulIdentifier","src":"1326:6:13"},"variableNames":[{"name":"value2","nodeType":"YulIdentifier","src":"1316:6:13"}]}]},"name":"abi_decode_tuple_t_bytes32t_bytes_calldata_ptr","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"735:9:13","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"746:7:13","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"758:6:13","type":""},{"name":"value1","nodeType":"YulTypedName","src":"766:6:13","type":""},{"name":"value2","nodeType":"YulTypedName","src":"774:6:13","type":""}],"src":"679:659:13"},{"body":{"nodeType":"YulBlock","src":"1442:103:13","statements":[{"nodeType":"YulAssignment","src":"1452:26:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1464:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"1475:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1460:3:13"},"nodeType":"YulFunctionCall","src":"1460:18:13"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"1452:4:13"}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"1494:9:13"},{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"1509:6:13"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1521:3:13","type":"","value":"224"},{"kind":"number","nodeType":"YulLiteral","src":"1526:10:13","type":"","value":"0xffffffff"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"1517:3:13"},"nodeType":"YulFunctionCall","src":"1517:20:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"1505:3:13"},"nodeType":"YulFunctionCall","src":"1505:33:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1487:6:13"},"nodeType":"YulFunctionCall","src":"1487:52:13"},"nodeType":"YulExpressionStatement","src":"1487:52:13"}]},"name":"abi_encode_tuple_t_bytes4__to_t_bytes4__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"1411:9:13","type":""},{"name":"value0","nodeType":"YulTypedName","src":"1422:6:13","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"1433:4:13","type":""}],"src":"1343:202:13"},{"body":{"nodeType":"YulBlock","src":"1582:95:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1599:1:13","type":"","value":"0"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1606:3:13","type":"","value":"224"},{"kind":"number","nodeType":"YulLiteral","src":"1611:10:13","type":"","value":"0x4e487b71"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"1602:3:13"},"nodeType":"YulFunctionCall","src":"1602:20:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1592:6:13"},"nodeType":"YulFunctionCall","src":"1592:31:13"},"nodeType":"YulExpressionStatement","src":"1592:31:13"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1639:1:13","type":"","value":"4"},{"kind":"number","nodeType":"YulLiteral","src":"1642:4:13","type":"","value":"0x41"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"1632:6:13"},"nodeType":"YulFunctionCall","src":"1632:15:13"},"nodeType":"YulExpressionStatement","src":"1632:15:13"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1663:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1666:4:13","type":"","value":"0x24"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1656:6:13"},"nodeType":"YulFunctionCall","src":"1656:15:13"},"nodeType":"YulExpressionStatement","src":"1656:15:13"}]},"name":"panic_error_0x41","nodeType":"YulFunctionDefinition","src":"1550:127:13"},{"body":{"nodeType":"YulBlock","src":"1734:666:13","statements":[{"body":{"nodeType":"YulBlock","src":"1783:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1792:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"1795:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"1785:6:13"},"nodeType":"YulFunctionCall","src":"1785:12:13"},"nodeType":"YulExpressionStatement","src":"1785:12:13"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"1762:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"1770:4:13","type":"","value":"0x1f"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"1758:3:13"},"nodeType":"YulFunctionCall","src":"1758:17:13"},{"name":"end","nodeType":"YulIdentifier","src":"1777:3:13"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"1754:3:13"},"nodeType":"YulFunctionCall","src":"1754:27:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"1747:6:13"},"nodeType":"YulFunctionCall","src":"1747:35:13"},"nodeType":"YulIf","src":"1744:55:13"},{"nodeType":"YulVariableDeclaration","src":"1808:30:13","value":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"1831:6:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"1818:12:13"},"nodeType":"YulFunctionCall","src":"1818:20:13"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"1812:2:13","type":""}]},{"nodeType":"YulVariableDeclaration","src":"1847:28:13","value":{"kind":"number","nodeType":"YulLiteral","src":"1857:18:13","type":"","value":"0xffffffffffffffff"},"variables":[{"name":"_2","nodeType":"YulTypedName","src":"1851:2:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"1898:22:13","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x41","nodeType":"YulIdentifier","src":"1900:16:13"},"nodeType":"YulFunctionCall","src":"1900:18:13"},"nodeType":"YulExpressionStatement","src":"1900:18:13"}]},"condition":{"arguments":[{"name":"_1","nodeType":"YulIdentifier","src":"1890:2:13"},{"name":"_2","nodeType":"YulIdentifier","src":"1894:2:13"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"1887:2:13"},"nodeType":"YulFunctionCall","src":"1887:10:13"},"nodeType":"YulIf","src":"1884:36:13"},{"nodeType":"YulVariableDeclaration","src":"1929:17:13","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1943:2:13","type":"","value":"31"}],"functionName":{"name":"not","nodeType":"YulIdentifier","src":"1939:3:13"},"nodeType":"YulFunctionCall","src":"1939:7:13"},"variables":[{"name":"_3","nodeType":"YulTypedName","src":"1933:2:13","type":""}]},{"nodeType":"YulVariableDeclaration","src":"1955:23:13","value":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"1975:2:13","type":"","value":"64"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"1969:5:13"},"nodeType":"YulFunctionCall","src":"1969:9:13"},"variables":[{"name":"memPtr","nodeType":"YulTypedName","src":"1959:6:13","type":""}]},{"nodeType":"YulVariableDeclaration","src":"1987:71:13","value":{"arguments":[{"name":"memPtr","nodeType":"YulIdentifier","src":"2009:6:13"},{"arguments":[{"arguments":[{"arguments":[{"arguments":[{"name":"_1","nodeType":"YulIdentifier","src":"2033:2:13"},{"kind":"number","nodeType":"YulLiteral","src":"2037:4:13","type":"","value":"0x1f"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2029:3:13"},"nodeType":"YulFunctionCall","src":"2029:13:13"},{"name":"_3","nodeType":"YulIdentifier","src":"2044:2:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"2025:3:13"},"nodeType":"YulFunctionCall","src":"2025:22:13"},{"kind":"number","nodeType":"YulLiteral","src":"2049:2:13","type":"","value":"63"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2021:3:13"},"nodeType":"YulFunctionCall","src":"2021:31:13"},{"name":"_3","nodeType":"YulIdentifier","src":"2054:2:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"2017:3:13"},"nodeType":"YulFunctionCall","src":"2017:40:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2005:3:13"},"nodeType":"YulFunctionCall","src":"2005:53:13"},"variables":[{"name":"newFreePtr","nodeType":"YulTypedName","src":"1991:10:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"2117:22:13","statements":[{"expression":{"arguments":[],"functionName":{"name":"panic_error_0x41","nodeType":"YulIdentifier","src":"2119:16:13"},"nodeType":"YulFunctionCall","src":"2119:18:13"},"nodeType":"YulExpressionStatement","src":"2119:18:13"}]},"condition":{"arguments":[{"arguments":[{"name":"newFreePtr","nodeType":"YulIdentifier","src":"2076:10:13"},{"name":"_2","nodeType":"YulIdentifier","src":"2088:2:13"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"2073:2:13"},"nodeType":"YulFunctionCall","src":"2073:18:13"},{"arguments":[{"name":"newFreePtr","nodeType":"YulIdentifier","src":"2096:10:13"},{"name":"memPtr","nodeType":"YulIdentifier","src":"2108:6:13"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"2093:2:13"},"nodeType":"YulFunctionCall","src":"2093:22:13"}],"functionName":{"name":"or","nodeType":"YulIdentifier","src":"2070:2:13"},"nodeType":"YulFunctionCall","src":"2070:46:13"},"nodeType":"YulIf","src":"2067:72:13"},{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2155:2:13","type":"","value":"64"},{"name":"newFreePtr","nodeType":"YulIdentifier","src":"2159:10:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2148:6:13"},"nodeType":"YulFunctionCall","src":"2148:22:13"},"nodeType":"YulExpressionStatement","src":"2148:22:13"},{"expression":{"arguments":[{"name":"memPtr","nodeType":"YulIdentifier","src":"2186:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"2194:2:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2179:6:13"},"nodeType":"YulFunctionCall","src":"2179:18:13"},"nodeType":"YulExpressionStatement","src":"2179:18:13"},{"body":{"nodeType":"YulBlock","src":"2245:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2254:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2257:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"2247:6:13"},"nodeType":"YulFunctionCall","src":"2247:12:13"},"nodeType":"YulExpressionStatement","src":"2247:12:13"}]},"condition":{"arguments":[{"arguments":[{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"2220:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"2228:2:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2216:3:13"},"nodeType":"YulFunctionCall","src":"2216:15:13"},{"kind":"number","nodeType":"YulLiteral","src":"2233:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2212:3:13"},"nodeType":"YulFunctionCall","src":"2212:26:13"},{"name":"end","nodeType":"YulIdentifier","src":"2240:3:13"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"2209:2:13"},"nodeType":"YulFunctionCall","src":"2209:35:13"},"nodeType":"YulIf","src":"2206:55:13"},{"expression":{"arguments":[{"arguments":[{"name":"memPtr","nodeType":"YulIdentifier","src":"2287:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"2295:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2283:3:13"},"nodeType":"YulFunctionCall","src":"2283:17:13"},{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"2306:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"2314:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2302:3:13"},"nodeType":"YulFunctionCall","src":"2302:17:13"},{"name":"_1","nodeType":"YulIdentifier","src":"2321:2:13"}],"functionName":{"name":"calldatacopy","nodeType":"YulIdentifier","src":"2270:12:13"},"nodeType":"YulFunctionCall","src":"2270:54:13"},"nodeType":"YulExpressionStatement","src":"2270:54:13"},{"expression":{"arguments":[{"arguments":[{"arguments":[{"name":"memPtr","nodeType":"YulIdentifier","src":"2348:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"2356:2:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2344:3:13"},"nodeType":"YulFunctionCall","src":"2344:15:13"},{"kind":"number","nodeType":"YulLiteral","src":"2361:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2340:3:13"},"nodeType":"YulFunctionCall","src":"2340:26:13"},{"kind":"number","nodeType":"YulLiteral","src":"2368:1:13","type":"","value":"0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2333:6:13"},"nodeType":"YulFunctionCall","src":"2333:37:13"},"nodeType":"YulExpressionStatement","src":"2333:37:13"},{"nodeType":"YulAssignment","src":"2379:15:13","value":{"name":"memPtr","nodeType":"YulIdentifier","src":"2388:6:13"},"variableNames":[{"name":"array","nodeType":"YulIdentifier","src":"2379:5:13"}]}]},"name":"abi_decode_bytes","nodeType":"YulFunctionDefinition","parameters":[{"name":"offset","nodeType":"YulTypedName","src":"1708:6:13","type":""},{"name":"end","nodeType":"YulTypedName","src":"1716:3:13","type":""}],"returnVariables":[{"name":"array","nodeType":"YulTypedName","src":"1724:5:13","type":""}],"src":"1682:718:13"},{"body":{"nodeType":"YulBlock","src":"2501:292:13","statements":[{"body":{"nodeType":"YulBlock","src":"2547:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2556:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2559:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"2549:6:13"},"nodeType":"YulFunctionCall","src":"2549:12:13"},"nodeType":"YulExpressionStatement","src":"2549:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"2522:7:13"},{"name":"headStart","nodeType":"YulIdentifier","src":"2531:9:13"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"2518:3:13"},"nodeType":"YulFunctionCall","src":"2518:23:13"},{"kind":"number","nodeType":"YulLiteral","src":"2543:2:13","type":"","value":"64"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"2514:3:13"},"nodeType":"YulFunctionCall","src":"2514:32:13"},"nodeType":"YulIf","src":"2511:52:13"},{"nodeType":"YulAssignment","src":"2572:33:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2595:9:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"2582:12:13"},"nodeType":"YulFunctionCall","src":"2582:23:13"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"2572:6:13"}]},{"nodeType":"YulVariableDeclaration","src":"2614:46:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2645:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"2656:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2641:3:13"},"nodeType":"YulFunctionCall","src":"2641:18:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"2628:12:13"},"nodeType":"YulFunctionCall","src":"2628:32:13"},"variables":[{"name":"offset","nodeType":"YulTypedName","src":"2618:6:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"2703:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"2712:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"2715:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"2705:6:13"},"nodeType":"YulFunctionCall","src":"2705:12:13"},"nodeType":"YulExpressionStatement","src":"2705:12:13"}]},"condition":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"2675:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"2683:18:13","type":"","value":"0xffffffffffffffff"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"2672:2:13"},"nodeType":"YulFunctionCall","src":"2672:30:13"},"nodeType":"YulIf","src":"2669:50:13"},{"nodeType":"YulAssignment","src":"2728:59:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"2759:9:13"},{"name":"offset","nodeType":"YulIdentifier","src":"2770:6:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2755:3:13"},"nodeType":"YulFunctionCall","src":"2755:22:13"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"2779:7:13"}],"functionName":{"name":"abi_decode_bytes","nodeType":"YulIdentifier","src":"2738:16:13"},"nodeType":"YulFunctionCall","src":"2738:49:13"},"variableNames":[{"name":"value1","nodeType":"YulIdentifier","src":"2728:6:13"}]}]},"name":"abi_decode_tuple_t_bytes32t_bytes_memory_ptr","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"2459:9:13","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"2470:7:13","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"2482:6:13","type":""},{"name":"value1","nodeType":"YulTypedName","src":"2490:6:13","type":""}],"src":"2405:388:13"},{"body":{"nodeType":"YulBlock","src":"2847:373:13","statements":[{"nodeType":"YulVariableDeclaration","src":"2857:26:13","value":{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"2877:5:13"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"2871:5:13"},"nodeType":"YulFunctionCall","src":"2871:12:13"},"variables":[{"name":"length","nodeType":"YulTypedName","src":"2861:6:13","type":""}]},{"expression":{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"2899:3:13"},{"name":"length","nodeType":"YulIdentifier","src":"2904:6:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"2892:6:13"},"nodeType":"YulFunctionCall","src":"2892:19:13"},"nodeType":"YulExpressionStatement","src":"2892:19:13"},{"nodeType":"YulVariableDeclaration","src":"2920:10:13","value":{"kind":"number","nodeType":"YulLiteral","src":"2929:1:13","type":"","value":"0"},"variables":[{"name":"i","nodeType":"YulTypedName","src":"2924:1:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"2991:110:13","statements":[{"nodeType":"YulVariableDeclaration","src":"3005:14:13","value":{"kind":"number","nodeType":"YulLiteral","src":"3015:4:13","type":"","value":"0x20"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"3009:2:13","type":""}]},{"expression":{"arguments":[{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3047:3:13"},{"name":"i","nodeType":"YulIdentifier","src":"3052:1:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3043:3:13"},"nodeType":"YulFunctionCall","src":"3043:11:13"},{"name":"_1","nodeType":"YulIdentifier","src":"3056:2:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3039:3:13"},"nodeType":"YulFunctionCall","src":"3039:20:13"},{"arguments":[{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3075:5:13"},{"name":"i","nodeType":"YulIdentifier","src":"3082:1:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3071:3:13"},"nodeType":"YulFunctionCall","src":"3071:13:13"},{"name":"_1","nodeType":"YulIdentifier","src":"3086:2:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3067:3:13"},"nodeType":"YulFunctionCall","src":"3067:22:13"}],"functionName":{"name":"mload","nodeType":"YulIdentifier","src":"3061:5:13"},"nodeType":"YulFunctionCall","src":"3061:29:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3032:6:13"},"nodeType":"YulFunctionCall","src":"3032:59:13"},"nodeType":"YulExpressionStatement","src":"3032:59:13"}]},"condition":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"2950:1:13"},{"name":"length","nodeType":"YulIdentifier","src":"2953:6:13"}],"functionName":{"name":"lt","nodeType":"YulIdentifier","src":"2947:2:13"},"nodeType":"YulFunctionCall","src":"2947:13:13"},"nodeType":"YulForLoop","post":{"nodeType":"YulBlock","src":"2961:21:13","statements":[{"nodeType":"YulAssignment","src":"2963:17:13","value":{"arguments":[{"name":"i","nodeType":"YulIdentifier","src":"2972:1:13"},{"kind":"number","nodeType":"YulLiteral","src":"2975:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"2968:3:13"},"nodeType":"YulFunctionCall","src":"2968:12:13"},"variableNames":[{"name":"i","nodeType":"YulIdentifier","src":"2963:1:13"}]}]},"pre":{"nodeType":"YulBlock","src":"2943:3:13","statements":[]},"src":"2939:162:13"},{"expression":{"arguments":[{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3125:3:13"},{"name":"length","nodeType":"YulIdentifier","src":"3130:6:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3121:3:13"},"nodeType":"YulFunctionCall","src":"3121:16:13"},{"kind":"number","nodeType":"YulLiteral","src":"3139:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3117:3:13"},"nodeType":"YulFunctionCall","src":"3117:27:13"},{"kind":"number","nodeType":"YulLiteral","src":"3146:1:13","type":"","value":"0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3110:6:13"},"nodeType":"YulFunctionCall","src":"3110:38:13"},"nodeType":"YulExpressionStatement","src":"3110:38:13"},{"nodeType":"YulAssignment","src":"3157:57:13","value":{"arguments":[{"arguments":[{"name":"pos","nodeType":"YulIdentifier","src":"3172:3:13"},{"arguments":[{"arguments":[{"name":"length","nodeType":"YulIdentifier","src":"3185:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"3193:2:13","type":"","value":"31"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3181:3:13"},"nodeType":"YulFunctionCall","src":"3181:15:13"},{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"3202:2:13","type":"","value":"31"}],"functionName":{"name":"not","nodeType":"YulIdentifier","src":"3198:3:13"},"nodeType":"YulFunctionCall","src":"3198:7:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"3177:3:13"},"nodeType":"YulFunctionCall","src":"3177:29:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3168:3:13"},"nodeType":"YulFunctionCall","src":"3168:39:13"},{"kind":"number","nodeType":"YulLiteral","src":"3209:4:13","type":"","value":"0x20"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3164:3:13"},"nodeType":"YulFunctionCall","src":"3164:50:13"},"variableNames":[{"name":"end","nodeType":"YulIdentifier","src":"3157:3:13"}]}]},"name":"abi_encode_bytes","nodeType":"YulFunctionDefinition","parameters":[{"name":"value","nodeType":"YulTypedName","src":"2824:5:13","type":""},{"name":"pos","nodeType":"YulTypedName","src":"2831:3:13","type":""}],"returnVariables":[{"name":"end","nodeType":"YulTypedName","src":"2839:3:13","type":""}],"src":"2798:422:13"},{"body":{"nodeType":"YulBlock","src":"3344:98:13","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3361:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"3372:2:13","type":"","value":"32"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"3354:6:13"},"nodeType":"YulFunctionCall","src":"3354:21:13"},"nodeType":"YulExpressionStatement","src":"3354:21:13"},{"nodeType":"YulAssignment","src":"3384:52:13","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"3409:6:13"},{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3421:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"3432:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3417:3:13"},"nodeType":"YulFunctionCall","src":"3417:18:13"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"3392:16:13"},"nodeType":"YulFunctionCall","src":"3392:44:13"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"3384:4:13"}]}]},"name":"abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"3313:9:13","type":""},{"name":"value0","nodeType":"YulTypedName","src":"3324:6:13","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"3335:4:13","type":""}],"src":"3225:217:13"},{"body":{"nodeType":"YulBlock","src":"3496:124:13","statements":[{"nodeType":"YulAssignment","src":"3506:29:13","value":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"3528:6:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"3515:12:13"},"nodeType":"YulFunctionCall","src":"3515:20:13"},"variableNames":[{"name":"value","nodeType":"YulIdentifier","src":"3506:5:13"}]},{"body":{"nodeType":"YulBlock","src":"3598:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"3607:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"3610:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"3600:6:13"},"nodeType":"YulFunctionCall","src":"3600:12:13"},"nodeType":"YulExpressionStatement","src":"3600:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3557:5:13"},{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"3568:5:13"},{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"3583:3:13","type":"","value":"160"},{"kind":"number","nodeType":"YulLiteral","src":"3588:1:13","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"3579:3:13"},"nodeType":"YulFunctionCall","src":"3579:11:13"},{"kind":"number","nodeType":"YulLiteral","src":"3592:1:13","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"3575:3:13"},"nodeType":"YulFunctionCall","src":"3575:19:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"3564:3:13"},"nodeType":"YulFunctionCall","src":"3564:31:13"}],"functionName":{"name":"eq","nodeType":"YulIdentifier","src":"3554:2:13"},"nodeType":"YulFunctionCall","src":"3554:42:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"3547:6:13"},"nodeType":"YulFunctionCall","src":"3547:50:13"},"nodeType":"YulIf","src":"3544:70:13"}]},"name":"abi_decode_address","nodeType":"YulFunctionDefinition","parameters":[{"name":"offset","nodeType":"YulTypedName","src":"3475:6:13","type":""}],"returnVariables":[{"name":"value","nodeType":"YulTypedName","src":"3486:5:13","type":""}],"src":"3447:173:13"},{"body":{"nodeType":"YulBlock","src":"3786:613:13","statements":[{"body":{"nodeType":"YulBlock","src":"3833:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"3842:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"3845:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"3835:6:13"},"nodeType":"YulFunctionCall","src":"3835:12:13"},"nodeType":"YulExpressionStatement","src":"3835:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"dataEnd","nodeType":"YulIdentifier","src":"3807:7:13"},{"name":"headStart","nodeType":"YulIdentifier","src":"3816:9:13"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"3803:3:13"},"nodeType":"YulFunctionCall","src":"3803:23:13"},{"kind":"number","nodeType":"YulLiteral","src":"3828:3:13","type":"","value":"192"}],"functionName":{"name":"slt","nodeType":"YulIdentifier","src":"3799:3:13"},"nodeType":"YulFunctionCall","src":"3799:33:13"},"nodeType":"YulIf","src":"3796:53:13"},{"nodeType":"YulAssignment","src":"3858:39:13","value":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3887:9:13"}],"functionName":{"name":"abi_decode_address","nodeType":"YulIdentifier","src":"3868:18:13"},"nodeType":"YulFunctionCall","src":"3868:29:13"},"variableNames":[{"name":"value0","nodeType":"YulIdentifier","src":"3858:6:13"}]},{"nodeType":"YulAssignment","src":"3906:48:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3939:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"3950:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3935:3:13"},"nodeType":"YulFunctionCall","src":"3935:18:13"}],"functionName":{"name":"abi_decode_address","nodeType":"YulIdentifier","src":"3916:18:13"},"nodeType":"YulFunctionCall","src":"3916:38:13"},"variableNames":[{"name":"value1","nodeType":"YulIdentifier","src":"3906:6:13"}]},{"nodeType":"YulAssignment","src":"3963:48:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"3996:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4007:2:13","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"3992:3:13"},"nodeType":"YulFunctionCall","src":"3992:18:13"}],"functionName":{"name":"abi_decode_address","nodeType":"YulIdentifier","src":"3973:18:13"},"nodeType":"YulFunctionCall","src":"3973:38:13"},"variableNames":[{"name":"value2","nodeType":"YulIdentifier","src":"3963:6:13"}]},{"nodeType":"YulAssignment","src":"4020:42:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4047:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4058:2:13","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4043:3:13"},"nodeType":"YulFunctionCall","src":"4043:18:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"4030:12:13"},"nodeType":"YulFunctionCall","src":"4030:32:13"},"variableNames":[{"name":"value3","nodeType":"YulIdentifier","src":"4020:6:13"}]},{"nodeType":"YulVariableDeclaration","src":"4071:46:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4101:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4112:3:13","type":"","value":"128"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4097:3:13"},"nodeType":"YulFunctionCall","src":"4097:19:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"4084:12:13"},"nodeType":"YulFunctionCall","src":"4084:33:13"},"variables":[{"name":"value","nodeType":"YulTypedName","src":"4075:5:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"4170:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"4179:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"4182:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"4172:6:13"},"nodeType":"YulFunctionCall","src":"4172:12:13"},"nodeType":"YulExpressionStatement","src":"4172:12:13"}]},"condition":{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"4139:5:13"},{"arguments":[{"arguments":[{"name":"value","nodeType":"YulIdentifier","src":"4160:5:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"4153:6:13"},"nodeType":"YulFunctionCall","src":"4153:13:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"4146:6:13"},"nodeType":"YulFunctionCall","src":"4146:21:13"}],"functionName":{"name":"eq","nodeType":"YulIdentifier","src":"4136:2:13"},"nodeType":"YulFunctionCall","src":"4136:32:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"4129:6:13"},"nodeType":"YulFunctionCall","src":"4129:40:13"},"nodeType":"YulIf","src":"4126:60:13"},{"nodeType":"YulAssignment","src":"4195:15:13","value":{"name":"value","nodeType":"YulIdentifier","src":"4205:5:13"},"variableNames":[{"name":"value4","nodeType":"YulIdentifier","src":"4195:6:13"}]},{"nodeType":"YulVariableDeclaration","src":"4219:47:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4250:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4261:3:13","type":"","value":"160"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4246:3:13"},"nodeType":"YulFunctionCall","src":"4246:19:13"}],"functionName":{"name":"calldataload","nodeType":"YulIdentifier","src":"4233:12:13"},"nodeType":"YulFunctionCall","src":"4233:33:13"},"variables":[{"name":"offset","nodeType":"YulTypedName","src":"4223:6:13","type":""}]},{"body":{"nodeType":"YulBlock","src":"4309:16:13","statements":[{"expression":{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"4318:1:13","type":"","value":"0"},{"kind":"number","nodeType":"YulLiteral","src":"4321:1:13","type":"","value":"0"}],"functionName":{"name":"revert","nodeType":"YulIdentifier","src":"4311:6:13"},"nodeType":"YulFunctionCall","src":"4311:12:13"},"nodeType":"YulExpressionStatement","src":"4311:12:13"}]},"condition":{"arguments":[{"name":"offset","nodeType":"YulIdentifier","src":"4281:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"4289:18:13","type":"","value":"0xffffffffffffffff"}],"functionName":{"name":"gt","nodeType":"YulIdentifier","src":"4278:2:13"},"nodeType":"YulFunctionCall","src":"4278:30:13"},"nodeType":"YulIf","src":"4275:50:13"},{"nodeType":"YulAssignment","src":"4334:59:13","value":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4365:9:13"},{"name":"offset","nodeType":"YulIdentifier","src":"4376:6:13"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4361:3:13"},"nodeType":"YulFunctionCall","src":"4361:22:13"},{"name":"dataEnd","nodeType":"YulIdentifier","src":"4385:7:13"}],"functionName":{"name":"abi_decode_bytes","nodeType":"YulIdentifier","src":"4344:16:13"},"nodeType":"YulFunctionCall","src":"4344:49:13"},"variableNames":[{"name":"value5","nodeType":"YulIdentifier","src":"4334:6:13"}]}]},"name":"abi_decode_tuple_t_addresst_addresst_addresst_bytes32t_boolt_bytes_memory_ptr","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"3712:9:13","type":""},{"name":"dataEnd","nodeType":"YulTypedName","src":"3723:7:13","type":""}],"returnVariables":[{"name":"value0","nodeType":"YulTypedName","src":"3735:6:13","type":""},{"name":"value1","nodeType":"YulTypedName","src":"3743:6:13","type":""},{"name":"value2","nodeType":"YulTypedName","src":"3751:6:13","type":""},{"name":"value3","nodeType":"YulTypedName","src":"3759:6:13","type":""},{"name":"value4","nodeType":"YulTypedName","src":"3767:6:13","type":""},{"name":"value5","nodeType":"YulTypedName","src":"3775:6:13","type":""}],"src":"3625:774:13"},{"body":{"nodeType":"YulBlock","src":"4623:221:13","statements":[{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4640:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4651:2:13","type":"","value":"64"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4633:6:13"},"nodeType":"YulFunctionCall","src":"4633:21:13"},"nodeType":"YulExpressionStatement","src":"4633:21:13"},{"nodeType":"YulVariableDeclaration","src":"4663:58:13","value":{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"4694:6:13"},{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4706:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4717:2:13","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4702:3:13"},"nodeType":"YulFunctionCall","src":"4702:18:13"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"4677:16:13"},"nodeType":"YulFunctionCall","src":"4677:44:13"},"variables":[{"name":"tail_1","nodeType":"YulTypedName","src":"4667:6:13","type":""}]},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"4741:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"4752:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4737:3:13"},"nodeType":"YulFunctionCall","src":"4737:18:13"},{"arguments":[{"name":"tail_1","nodeType":"YulIdentifier","src":"4761:6:13"},{"name":"headStart","nodeType":"YulIdentifier","src":"4769:9:13"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"4757:3:13"},"nodeType":"YulFunctionCall","src":"4757:22:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4730:6:13"},"nodeType":"YulFunctionCall","src":"4730:50:13"},"nodeType":"YulExpressionStatement","src":"4730:50:13"},{"expression":{"arguments":[{"name":"tail_1","nodeType":"YulIdentifier","src":"4796:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"4804:1:13","type":"","value":"0"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"4789:6:13"},"nodeType":"YulFunctionCall","src":"4789:17:13"},"nodeType":"YulExpressionStatement","src":"4789:17:13"},{"nodeType":"YulAssignment","src":"4815:23:13","value":{"arguments":[{"name":"tail_1","nodeType":"YulIdentifier","src":"4827:6:13"},{"kind":"number","nodeType":"YulLiteral","src":"4835:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"4823:3:13"},"nodeType":"YulFunctionCall","src":"4823:15:13"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"4815:4:13"}]}]},"name":"abi_encode_tuple_t_bytes_memory_ptr_t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470__to_t_bytes_memory_ptr_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"4592:9:13","type":""},{"name":"value0","nodeType":"YulTypedName","src":"4603:6:13","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"4614:4:13","type":""}],"src":"4404:440:13"},{"body":{"nodeType":"YulBlock","src":"5074:345:13","statements":[{"nodeType":"YulVariableDeclaration","src":"5084:29:13","value":{"arguments":[{"arguments":[{"kind":"number","nodeType":"YulLiteral","src":"5102:3:13","type":"","value":"160"},{"kind":"number","nodeType":"YulLiteral","src":"5107:1:13","type":"","value":"1"}],"functionName":{"name":"shl","nodeType":"YulIdentifier","src":"5098:3:13"},"nodeType":"YulFunctionCall","src":"5098:11:13"},{"kind":"number","nodeType":"YulLiteral","src":"5111:1:13","type":"","value":"1"}],"functionName":{"name":"sub","nodeType":"YulIdentifier","src":"5094:3:13"},"nodeType":"YulFunctionCall","src":"5094:19:13"},"variables":[{"name":"_1","nodeType":"YulTypedName","src":"5088:2:13","type":""}]},{"expression":{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5129:9:13"},{"arguments":[{"name":"value0","nodeType":"YulIdentifier","src":"5144:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"5152:2:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"5140:3:13"},"nodeType":"YulFunctionCall","src":"5140:15:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5122:6:13"},"nodeType":"YulFunctionCall","src":"5122:34:13"},"nodeType":"YulExpressionStatement","src":"5122:34:13"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5176:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"5187:2:13","type":"","value":"32"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5172:3:13"},"nodeType":"YulFunctionCall","src":"5172:18:13"},{"arguments":[{"name":"value1","nodeType":"YulIdentifier","src":"5196:6:13"},{"name":"_1","nodeType":"YulIdentifier","src":"5204:2:13"}],"functionName":{"name":"and","nodeType":"YulIdentifier","src":"5192:3:13"},"nodeType":"YulFunctionCall","src":"5192:15:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5165:6:13"},"nodeType":"YulFunctionCall","src":"5165:43:13"},"nodeType":"YulExpressionStatement","src":"5165:43:13"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5228:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"5239:2:13","type":"","value":"64"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5224:3:13"},"nodeType":"YulFunctionCall","src":"5224:18:13"},{"name":"value2","nodeType":"YulIdentifier","src":"5244:6:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5217:6:13"},"nodeType":"YulFunctionCall","src":"5217:34:13"},"nodeType":"YulExpressionStatement","src":"5217:34:13"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5271:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"5282:2:13","type":"","value":"96"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5267:3:13"},"nodeType":"YulFunctionCall","src":"5267:18:13"},{"arguments":[{"arguments":[{"name":"value3","nodeType":"YulIdentifier","src":"5301:6:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"5294:6:13"},"nodeType":"YulFunctionCall","src":"5294:14:13"}],"functionName":{"name":"iszero","nodeType":"YulIdentifier","src":"5287:6:13"},"nodeType":"YulFunctionCall","src":"5287:22:13"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5260:6:13"},"nodeType":"YulFunctionCall","src":"5260:50:13"},"nodeType":"YulExpressionStatement","src":"5260:50:13"},{"expression":{"arguments":[{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5330:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"5341:3:13","type":"","value":"128"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5326:3:13"},"nodeType":"YulFunctionCall","src":"5326:19:13"},{"kind":"number","nodeType":"YulLiteral","src":"5347:3:13","type":"","value":"160"}],"functionName":{"name":"mstore","nodeType":"YulIdentifier","src":"5319:6:13"},"nodeType":"YulFunctionCall","src":"5319:32:13"},"nodeType":"YulExpressionStatement","src":"5319:32:13"},{"nodeType":"YulAssignment","src":"5360:53:13","value":{"arguments":[{"name":"value4","nodeType":"YulIdentifier","src":"5385:6:13"},{"arguments":[{"name":"headStart","nodeType":"YulIdentifier","src":"5397:9:13"},{"kind":"number","nodeType":"YulLiteral","src":"5408:3:13","type":"","value":"160"}],"functionName":{"name":"add","nodeType":"YulIdentifier","src":"5393:3:13"},"nodeType":"YulFunctionCall","src":"5393:19:13"}],"functionName":{"name":"abi_encode_bytes","nodeType":"YulIdentifier","src":"5368:16:13"},"nodeType":"YulFunctionCall","src":"5368:45:13"},"variableNames":[{"name":"tail","nodeType":"YulIdentifier","src":"5360:4:13"}]}]},"name":"abi_encode_tuple_t_address_t_address_t_bytes32_t_bool_t_bytes_memory_ptr__to_t_address_t_address_t_bytes32_t_bool_t_bytes_memory_ptr__fromStack_reversed","nodeType":"YulFunctionDefinition","parameters":[{"name":"headStart","nodeType":"YulTypedName","src":"5011:9:13","type":""},{"name":"value4","nodeType":"YulTypedName","src":"5022:6:13","type":""},{"name":"value3","nodeType":"YulTypedName","src":"5030:6:13","type":""},{"name":"value2","nodeType":"YulTypedName","src":"5038:6:13","type":""},{"name":"value1","nodeType":"YulTypedName","src":"5046:6:13","type":""},{"name":"value0","nodeType":"YulTypedName","src":"5054:6:13","type":""}],"returnVariables":[{"name":"tail","nodeType":"YulTypedName","src":"5065:4:13","type":""}],"src":"4849:570:13"}]},"contents":"{\n    { }\n    function abi_decode_tuple_t_bytes4(headStart, dataEnd) -> value0\n    {\n        if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }\n        let value := calldataload(headStart)\n        if iszero(eq(value, and(value, shl(224, 0xffffffff)))) { revert(0, 0) }\n        value0 := value\n    }\n    function abi_encode_tuple_t_bool__to_t_bool__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, iszero(iszero(value0)))\n    }\n    function abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, value0)\n    }\n    function abi_decode_tuple_t_bytes32t_bytes_calldata_ptr(headStart, dataEnd) -> value0, value1, value2\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        value0 := calldataload(headStart)\n        let offset := calldataload(add(headStart, 32))\n        let _1 := 0xffffffffffffffff\n        if gt(offset, _1) { revert(0, 0) }\n        let _2 := add(headStart, offset)\n        if iszero(slt(add(_2, 0x1f), dataEnd)) { revert(0, 0) }\n        let length := calldataload(_2)\n        if gt(length, _1) { revert(0, 0) }\n        if gt(add(add(_2, length), 32), dataEnd) { revert(0, 0) }\n        value1 := add(_2, 32)\n        value2 := length\n    }\n    function abi_encode_tuple_t_bytes4__to_t_bytes4__fromStack_reversed(headStart, value0) -> tail\n    {\n        tail := add(headStart, 32)\n        mstore(headStart, and(value0, shl(224, 0xffffffff)))\n    }\n    function panic_error_0x41()\n    {\n        mstore(0, shl(224, 0x4e487b71))\n        mstore(4, 0x41)\n        revert(0, 0x24)\n    }\n    function abi_decode_bytes(offset, end) -> array\n    {\n        if iszero(slt(add(offset, 0x1f), end)) { revert(0, 0) }\n        let _1 := calldataload(offset)\n        let _2 := 0xffffffffffffffff\n        if gt(_1, _2) { panic_error_0x41() }\n        let _3 := not(31)\n        let memPtr := mload(64)\n        let newFreePtr := add(memPtr, and(add(and(add(_1, 0x1f), _3), 63), _3))\n        if or(gt(newFreePtr, _2), lt(newFreePtr, memPtr)) { panic_error_0x41() }\n        mstore(64, newFreePtr)\n        mstore(memPtr, _1)\n        if gt(add(add(offset, _1), 0x20), end) { revert(0, 0) }\n        calldatacopy(add(memPtr, 0x20), add(offset, 0x20), _1)\n        mstore(add(add(memPtr, _1), 0x20), 0)\n        array := memPtr\n    }\n    function abi_decode_tuple_t_bytes32t_bytes_memory_ptr(headStart, dataEnd) -> value0, value1\n    {\n        if slt(sub(dataEnd, headStart), 64) { revert(0, 0) }\n        value0 := calldataload(headStart)\n        let offset := calldataload(add(headStart, 32))\n        if gt(offset, 0xffffffffffffffff) { revert(0, 0) }\n        value1 := abi_decode_bytes(add(headStart, offset), dataEnd)\n    }\n    function abi_encode_bytes(value, pos) -> end\n    {\n        let length := mload(value)\n        mstore(pos, length)\n        let i := 0\n        for { } lt(i, length) { i := add(i, 0x20) }\n        {\n            let _1 := 0x20\n            mstore(add(add(pos, i), _1), mload(add(add(value, i), _1)))\n        }\n        mstore(add(add(pos, length), 0x20), 0)\n        end := add(add(pos, and(add(length, 31), not(31))), 0x20)\n    }\n    function abi_encode_tuple_t_bytes_memory_ptr__to_t_bytes_memory_ptr__fromStack_reversed(headStart, value0) -> tail\n    {\n        mstore(headStart, 32)\n        tail := abi_encode_bytes(value0, add(headStart, 32))\n    }\n    function abi_decode_address(offset) -> value\n    {\n        value := calldataload(offset)\n        if iszero(eq(value, and(value, sub(shl(160, 1), 1)))) { revert(0, 0) }\n    }\n    function abi_decode_tuple_t_addresst_addresst_addresst_bytes32t_boolt_bytes_memory_ptr(headStart, dataEnd) -> value0, value1, value2, value3, value4, value5\n    {\n        if slt(sub(dataEnd, headStart), 192) { revert(0, 0) }\n        value0 := abi_decode_address(headStart)\n        value1 := abi_decode_address(add(headStart, 32))\n        value2 := abi_decode_address(add(headStart, 64))\n        value3 := calldataload(add(headStart, 96))\n        let value := calldataload(add(headStart, 128))\n        if iszero(eq(value, iszero(iszero(value)))) { revert(0, 0) }\n        value4 := value\n        let offset := calldataload(add(headStart, 160))\n        if gt(offset, 0xffffffffffffffff) { revert(0, 0) }\n        value5 := abi_decode_bytes(add(headStart, offset), dataEnd)\n    }\n    function abi_encode_tuple_t_bytes_memory_ptr_t_stringliteral_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470__to_t_bytes_memory_ptr_t_bytes_memory_ptr__fromStack_reversed(headStart, value0) -> tail\n    {\n        mstore(headStart, 64)\n        let tail_1 := abi_encode_bytes(value0, add(headStart, 64))\n        mstore(add(headStart, 32), sub(tail_1, headStart))\n        mstore(tail_1, 0)\n        tail := add(tail_1, 32)\n    }\n    function abi_encode_tuple_t_address_t_address_t_bytes32_t_bool_t_bytes_memory_ptr__to_t_address_t_address_t_bytes32_t_bool_t_bytes_memory_ptr__fromStack_reversed(headStart, value4, value3, value2, value1, value0) -> tail\n    {\n        let _1 := sub(shl(160, 1), 1)\n        mstore(headStart, and(value0, _1))\n        mstore(add(headStart, 32), and(value1, _1))\n        mstore(add(headStart, 64), value2)\n        mstore(add(headStart, 96), iszero(iszero(value3)))\n        mstore(add(headStart, 128), 160)\n        tail := abi_encode_bytes(value4, add(headStart, 160))\n    }\n}","id":13,"language":"Yul","name":"#utility.yul"}],"immutableReferences":{},"linkReferences":{},"object":"6080604052600436106100565760003560e01c806301ffc9a71461005f57806312065fe0146100945780631626ba7e146100af5780636bb56a14146100f2578063876e93fe14610112578063b60d42881461005d57005b3661005d57005b005b34801561006b57600080fd5b5061007f61007a366004610267565b610132565b60405190151581526020015b60405180910390f35b3480156100a057600080fd5b5060405147815260200161008b565b3480156100bb57600080fd5b506100d96100ca366004610298565b630b135d3f60e11b9392505050565b6040516001600160e01b0319909116815260200161008b565b6101056101003660046103b7565b610184565b60405161008b9190610444565b34801561011e57600080fd5b5061005d61012d366004610473565b6101f9565b60006001600160e01b03198216631aed5a8560e21b148061016357506001600160e01b031982166324871b3d60e01b145b8061017e57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60608234336001600160a01b03167f9c3ba68eb5742b8e3961aea0afc7371a71bf433c8a67a831803b64c064a178c2856040516101c19190610502565b60405180910390a4506040805180820190915260128152717468616e6b7320666f722063616c6c696e6760701b602082015292915050565b60405163288db4a960e11b81526001600160a01b0387169063511b69529061022d908890889088908890889060040161052c565b600060405180830381600087803b15801561024757600080fd5b505af115801561025b573d6000803e3d6000fd5b50505050505050505050565b60006020828403121561027957600080fd5b81356001600160e01b03198116811461029157600080fd5b9392505050565b6000806000604084860312156102ad57600080fd5b83359250602084013567ffffffffffffffff808211156102cc57600080fd5b818601915086601f8301126102e057600080fd5b8135818111156102ef57600080fd5b87602082850101111561030157600080fd5b6020830194508093505050509250925092565b634e487b7160e01b600052604160045260246000fd5b600082601f83011261033b57600080fd5b813567ffffffffffffffff8082111561035657610356610314565b604051601f8301601f19908116603f0116810190828211818310171561037e5761037e610314565b8160405283815286602085880101111561039757600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080604083850312156103ca57600080fd5b82359150602083013567ffffffffffffffff8111156103e857600080fd5b6103f48582860161032a565b9150509250929050565b6000815180845260005b8181101561042457602081850181015186830182015201610408565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061029160208301846103fe565b80356001600160a01b038116811461046e57600080fd5b919050565b60008060008060008060c0878903121561048c57600080fd5b61049587610457565b95506104a360208801610457565b94506104b160408801610457565b935060608701359250608087013580151581146104cd57600080fd5b915060a087013567ffffffffffffffff8111156104e957600080fd5b6104f589828a0161032a565b9150509295509295509295565b60408152600061051560408301846103fe565b828103602093840152600081529190910192915050565b6001600160a01b0386811682528516602082015260408101849052821515606082015260a060808201819052600090610567908301846103fe565b97965050505050505056fea2646970667358221220e15eeaadee6d8f52262118cba70aea5892b939de7f4493effd8e9223da481c1c64736f6c63430008140033","opcodes":"PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH2 0x56 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x1FFC9A7 EQ PUSH2 0x5F JUMPI DUP1 PUSH4 0x12065FE0 EQ PUSH2 0x94 JUMPI DUP1 PUSH4 0x1626BA7E EQ PUSH2 0xAF JUMPI DUP1 PUSH4 0x6BB56A14 EQ PUSH2 0xF2 JUMPI DUP1 PUSH4 0x876E93FE EQ PUSH2 0x112 JUMPI DUP1 PUSH4 0xB60D4288 EQ PUSH2 0x5D JUMPI STOP JUMPDEST CALLDATASIZE PUSH2 0x5D JUMPI STOP JUMPDEST STOP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x6B JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x7F PUSH2 0x7A CALLDATASIZE PUSH1 0x4 PUSH2 0x267 JUMP JUMPDEST PUSH2 0x132 JUMP JUMPDEST PUSH1 0x40 MLOAD SWAP1 ISZERO ISZERO DUP2 MSTORE PUSH1 0x20 ADD JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xA0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD SELFBALANCE DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0x8B JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0xBB JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0xD9 PUSH2 0xCA CALLDATASIZE PUSH1 0x4 PUSH2 0x298 JUMP JUMPDEST PUSH4 0xB135D3F PUSH1 0xE1 SHL SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT SWAP1 SWAP2 AND DUP2 MSTORE PUSH1 0x20 ADD PUSH2 0x8B JUMP JUMPDEST PUSH2 0x105 PUSH2 0x100 CALLDATASIZE PUSH1 0x4 PUSH2 0x3B7 JUMP JUMPDEST PUSH2 0x184 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH2 0x8B SWAP2 SWAP1 PUSH2 0x444 JUMP JUMPDEST CALLVALUE DUP1 ISZERO PUSH2 0x11E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x5D PUSH2 0x12D CALLDATASIZE PUSH1 0x4 PUSH2 0x473 JUMP JUMPDEST PUSH2 0x1F9 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP3 AND PUSH4 0x1AED5A85 PUSH1 0xE2 SHL EQ DUP1 PUSH2 0x163 JUMPI POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP3 AND PUSH4 0x24871B3D PUSH1 0xE0 SHL EQ JUMPDEST DUP1 PUSH2 0x17E JUMPI POP PUSH4 0x1FFC9A7 PUSH1 0xE0 SHL PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP4 AND EQ JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x60 DUP3 CALLVALUE CALLER PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH32 0x9C3BA68EB5742B8E3961AEA0AFC7371A71BF433C8A67A831803B64C064A178C2 DUP6 PUSH1 0x40 MLOAD PUSH2 0x1C1 SWAP2 SWAP1 PUSH2 0x502 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG4 POP PUSH1 0x40 DUP1 MLOAD DUP1 DUP3 ADD SWAP1 SWAP2 MSTORE PUSH1 0x12 DUP2 MSTORE PUSH18 0x7468616E6B7320666F722063616C6C696E67 PUSH1 0x70 SHL PUSH1 0x20 DUP3 ADD MSTORE SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH4 0x288DB4A9 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP8 AND SWAP1 PUSH4 0x511B6952 SWAP1 PUSH2 0x22D SWAP1 DUP9 SWAP1 DUP9 SWAP1 DUP9 SWAP1 DUP9 SWAP1 DUP9 SWAP1 PUSH1 0x4 ADD PUSH2 0x52C JUMP JUMPDEST PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x247 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x25B JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP POP POP POP POP POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 DUP5 SUB SLT ISZERO PUSH2 0x279 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xE0 SHL SUB NOT DUP2 AND DUP2 EQ PUSH2 0x291 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 PUSH1 0x40 DUP5 DUP7 SUB SLT ISZERO PUSH2 0x2AD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 CALLDATALOAD SWAP3 POP PUSH1 0x20 DUP5 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x2CC JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 DUP7 ADD SWAP2 POP DUP7 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x2E0 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD DUP2 DUP2 GT ISZERO PUSH2 0x2EF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP8 PUSH1 0x20 DUP3 DUP6 ADD ADD GT ISZERO PUSH2 0x301 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x20 DUP4 ADD SWAP5 POP DUP1 SWAP4 POP POP POP POP SWAP3 POP SWAP3 POP SWAP3 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH1 0x0 DUP3 PUSH1 0x1F DUP4 ADD SLT PUSH2 0x33B JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP1 DUP3 GT ISZERO PUSH2 0x356 JUMPI PUSH2 0x356 PUSH2 0x314 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x1F DUP4 ADD PUSH1 0x1F NOT SWAP1 DUP2 AND PUSH1 0x3F ADD AND DUP2 ADD SWAP1 DUP3 DUP3 GT DUP2 DUP4 LT OR ISZERO PUSH2 0x37E JUMPI PUSH2 0x37E PUSH2 0x314 JUMP JUMPDEST DUP2 PUSH1 0x40 MSTORE DUP4 DUP2 MSTORE DUP7 PUSH1 0x20 DUP6 DUP9 ADD ADD GT ISZERO PUSH2 0x397 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP4 PUSH1 0x20 DUP8 ADD PUSH1 0x20 DUP4 ADD CALLDATACOPY PUSH1 0x0 PUSH1 0x20 DUP6 DUP4 ADD ADD MSTORE DUP1 SWAP5 POP POP POP POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x40 DUP4 DUP6 SUB SLT ISZERO PUSH2 0x3CA JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP3 CALLDATALOAD SWAP2 POP PUSH1 0x20 DUP4 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x3E8 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x3F4 DUP6 DUP3 DUP7 ADD PUSH2 0x32A JUMP JUMPDEST SWAP2 POP POP SWAP3 POP SWAP3 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP2 MLOAD DUP1 DUP5 MSTORE PUSH1 0x0 JUMPDEST DUP2 DUP2 LT ISZERO PUSH2 0x424 JUMPI PUSH1 0x20 DUP2 DUP6 ADD DUP2 ADD MLOAD DUP7 DUP4 ADD DUP3 ADD MSTORE ADD PUSH2 0x408 JUMP JUMPDEST POP PUSH1 0x0 PUSH1 0x20 DUP3 DUP7 ADD ADD MSTORE PUSH1 0x20 PUSH1 0x1F NOT PUSH1 0x1F DUP4 ADD AND DUP6 ADD ADD SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x20 DUP2 MSTORE PUSH1 0x0 PUSH2 0x291 PUSH1 0x20 DUP4 ADD DUP5 PUSH2 0x3FE JUMP JUMPDEST DUP1 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 EQ PUSH2 0x46E JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0x0 DUP1 PUSH1 0xC0 DUP8 DUP10 SUB SLT ISZERO PUSH2 0x48C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x495 DUP8 PUSH2 0x457 JUMP JUMPDEST SWAP6 POP PUSH2 0x4A3 PUSH1 0x20 DUP9 ADD PUSH2 0x457 JUMP JUMPDEST SWAP5 POP PUSH2 0x4B1 PUSH1 0x40 DUP9 ADD PUSH2 0x457 JUMP JUMPDEST SWAP4 POP PUSH1 0x60 DUP8 ADD CALLDATALOAD SWAP3 POP PUSH1 0x80 DUP8 ADD CALLDATALOAD DUP1 ISZERO ISZERO DUP2 EQ PUSH2 0x4CD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST SWAP2 POP PUSH1 0xA0 DUP8 ADD CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT ISZERO PUSH2 0x4E9 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x4F5 DUP10 DUP3 DUP11 ADD PUSH2 0x32A JUMP JUMPDEST SWAP2 POP POP SWAP3 SWAP6 POP SWAP3 SWAP6 POP SWAP3 SWAP6 JUMP JUMPDEST PUSH1 0x40 DUP2 MSTORE PUSH1 0x0 PUSH2 0x515 PUSH1 0x40 DUP4 ADD DUP5 PUSH2 0x3FE JUMP JUMPDEST DUP3 DUP2 SUB PUSH1 0x20 SWAP4 DUP5 ADD MSTORE PUSH1 0x0 DUP2 MSTORE SWAP2 SWAP1 SWAP2 ADD SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP7 DUP2 AND DUP3 MSTORE DUP6 AND PUSH1 0x20 DUP3 ADD MSTORE PUSH1 0x40 DUP2 ADD DUP5 SWAP1 MSTORE DUP3 ISZERO ISZERO PUSH1 0x60 DUP3 ADD MSTORE PUSH1 0xA0 PUSH1 0x80 DUP3 ADD DUP2 SWAP1 MSTORE PUSH1 0x0 SWAP1 PUSH2 0x567 SWAP1 DUP4 ADD DUP5 PUSH2 0x3FE JUMP JUMPDEST SWAP8 SWAP7 POP POP POP POP POP POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 0xE1 0x5E 0xEA 0xAD 0xEE PUSH14 0x8F52262118CBA70AEA5892B939DE PUSH32 0x4493EFFD8E9223DA481C1C64736F6C6343000814003300000000000000000000 ","sourceMap":"667:1476:12:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;788:303;;;;;;;;;;-1:-1:-1;788:303:12;;;;;:::i;:::-;;:::i;:::-;;;470:14:13;;463:22;445:41;;433:2;418:18;788:303:12;;;;;;;;1973:99;;;;;;;;;;-1:-1:-1;1973:99:12;;2044:21;643:25:13;;631:2;616:18;1973:99:12;497:177:13;1458:221:12;;;;;;;;;;-1:-1:-1;1458:221:12;;;;;:::i;:::-;-1:-1:-1;;;1458:221:12;;;;;;;;;-1:-1:-1;;;;;;1505:33:13;;;1487:52;;1475:2;1460:18;1458:221:12;1343:202:13;1096:263:12;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;1684:244::-;;;;;;;;;;-1:-1:-1;1684:244:12;;;;;:::i;:::-;;:::i;788:303::-;913:4;-1:-1:-1;;;;;;952:32:12;;-1:-1:-1;;;952:32:12;;:80;;-1:-1:-1;;;;;;;1000:32:12;;-1:-1:-1;;;1000:32:12;952:80;:132;;;-1:-1:-1;;;;;;;;;;861:40:9;;;1048:36:12;933:151;788:303;-1:-1:-1;;788:303:12:o;1096:263::-;1215:24;1297:6;1286:9;1274:10;-1:-1:-1;;;;;1256:58:12;;1305:4;1256:58;;;;;;:::i;:::-;;;;;;;;-1:-1:-1;1325:27:12;;;;;;;;;;;;-1:-1:-1;;;1325:27:12;;;;1096:263;;;;:::o;1684:244::-;1865:56;;-1:-1:-1;;;1865:56:12;;-1:-1:-1;;;;;1865:24:12;;;;;:56;;1890:4;;1896:2;;1900:7;;1909:5;;1916:4;;1865:56;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;1684:244;;;;;;:::o;14:286:13:-;72:6;125:2;113:9;104:7;100:23;96:32;93:52;;;141:1;138;131:12;93:52;167:23;;-1:-1:-1;;;;;;219:32:13;;209:43;;199:71;;266:1;263;256:12;199:71;289:5;14:286;-1:-1:-1;;;14:286:13:o;679:659::-;758:6;766;774;827:2;815:9;806:7;802:23;798:32;795:52;;;843:1;840;833:12;795:52;879:9;866:23;856:33;;940:2;929:9;925:18;912:32;963:18;1004:2;996:6;993:14;990:34;;;1020:1;1017;1010:12;990:34;1058:6;1047:9;1043:22;1033:32;;1103:7;1096:4;1092:2;1088:13;1084:27;1074:55;;1125:1;1122;1115:12;1074:55;1165:2;1152:16;1191:2;1183:6;1180:14;1177:34;;;1207:1;1204;1197:12;1177:34;1252:7;1247:2;1238:6;1234:2;1230:15;1226:24;1223:37;1220:57;;;1273:1;1270;1263:12;1220:57;1304:2;1300;1296:11;1286:21;;1326:6;1316:16;;;;;679:659;;;;;:::o;1550:127::-;1611:10;1606:3;1602:20;1599:1;1592:31;1642:4;1639:1;1632:15;1666:4;1663:1;1656:15;1682:718;1724:5;1777:3;1770:4;1762:6;1758:17;1754:27;1744:55;;1795:1;1792;1785:12;1744:55;1831:6;1818:20;1857:18;1894:2;1890;1887:10;1884:36;;;1900:18;;:::i;:::-;1975:2;1969:9;1943:2;2029:13;;-1:-1:-1;;2025:22:13;;;2049:2;2021:31;2017:40;2005:53;;;2073:18;;;2093:22;;;2070:46;2067:72;;;2119:18;;:::i;:::-;2159:10;2155:2;2148:22;2194:2;2186:6;2179:18;2240:3;2233:4;2228:2;2220:6;2216:15;2212:26;2209:35;2206:55;;;2257:1;2254;2247:12;2206:55;2321:2;2314:4;2306:6;2302:17;2295:4;2287:6;2283:17;2270:54;2368:1;2361:4;2356:2;2348:6;2344:15;2340:26;2333:37;2388:6;2379:15;;;;;;1682:718;;;;:::o;2405:388::-;2482:6;2490;2543:2;2531:9;2522:7;2518:23;2514:32;2511:52;;;2559:1;2556;2549:12;2511:52;2595:9;2582:23;2572:33;;2656:2;2645:9;2641:18;2628:32;2683:18;2675:6;2672:30;2669:50;;;2715:1;2712;2705:12;2669:50;2738:49;2779:7;2770:6;2759:9;2755:22;2738:49;:::i;:::-;2728:59;;;2405:388;;;;;:::o;2798:422::-;2839:3;2877:5;2871:12;2904:6;2899:3;2892:19;2929:1;2939:162;2953:6;2950:1;2947:13;2939:162;;;3015:4;3071:13;;;3067:22;;3061:29;3043:11;;;3039:20;;3032:59;2968:12;2939:162;;;2943:3;3146:1;3139:4;3130:6;3125:3;3121:16;3117:27;3110:38;3209:4;3202:2;3198:7;3193:2;3185:6;3181:15;3177:29;3172:3;3168:39;3164:50;3157:57;;;2798:422;;;;:::o;3225:217::-;3372:2;3361:9;3354:21;3335:4;3392:44;3432:2;3421:9;3417:18;3409:6;3392:44;:::i;3447:173::-;3515:20;;-1:-1:-1;;;;;3564:31:13;;3554:42;;3544:70;;3610:1;3607;3600:12;3544:70;3447:173;;;:::o;3625:774::-;3735:6;3743;3751;3759;3767;3775;3828:3;3816:9;3807:7;3803:23;3799:33;3796:53;;;3845:1;3842;3835:12;3796:53;3868:29;3887:9;3868:29;:::i;:::-;3858:39;;3916:38;3950:2;3939:9;3935:18;3916:38;:::i;:::-;3906:48;;3973:38;4007:2;3996:9;3992:18;3973:38;:::i;:::-;3963:48;;4058:2;4047:9;4043:18;4030:32;4020:42;;4112:3;4101:9;4097:19;4084:33;4160:5;4153:13;4146:21;4139:5;4136:32;4126:60;;4182:1;4179;4172:12;4126:60;4205:5;-1:-1:-1;4261:3:13;4246:19;;4233:33;4289:18;4278:30;;4275:50;;;4321:1;4318;4311:12;4275:50;4344:49;4385:7;4376:6;4365:9;4361:22;4344:49;:::i;:::-;4334:59;;;3625:774;;;;;;;;:::o;4404:440::-;4651:2;4640:9;4633:21;4614:4;4677:44;4717:2;4706:9;4702:18;4694:6;4677:44;:::i;:::-;4757:22;;;4752:2;4737:18;;;4730:50;4804:1;4789:17;;4823:15;;;;;4404:440;-1:-1:-1;;4404:440:13:o;4849:570::-;-1:-1:-1;;;;;5140:15:13;;;5122:34;;5192:15;;5187:2;5172:18;;5165:43;5239:2;5224:18;;5217:34;;;5294:14;;5287:22;5282:2;5267:18;;5260:50;5102:3;5341;5326:19;;5319:32;;;5065:4;;5368:45;;5393:19;;5385:6;5368:45;:::i;:::-;5360:53;4849:570;-1:-1:-1;;;;;;;4849:570:13:o"},"gasEstimates":{"creation":{"codeDepositCost":"289600","executionCost":"331","totalCost":"289931"},"external":{"":"183","fund()":"184","getBalance()":"179","isValidSignature(bytes32,bytes)":"532","supportsInterface(bytes4)":"459","transfer(address,address,address,bytes32,bool,bytes)":"infinite","universalReceiver(bytes32,bytes)":"infinite"}},"methodIdentifiers":{"fund()":"b60d4288","getBalance()":"12065fe0","isValidSignature(bytes32,bytes)":"1626ba7e","supportsInterface(bytes4)":"01ffc9a7","transfer(address,address,address,bytes32,bool,bytes)":"876e93fe","universalReceiver(bytes32,bytes)":"6bb56a14"}},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"typeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"receivedData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnedValue\",\"type\":\"bytes\"}],\"name\":\"UniversalReceiver\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shirts\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"tokenId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"typeId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"universalReceiver\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"returnValue\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"events\":{\"UniversalReceiver(address,uint256,bytes32,bytes,bytes)\":{\"details\":\"Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\",\"params\":{\"from\":\"The address of the EOA or smart contract that called the {universalReceiver(...)} function.\",\"receivedData\":\"Any arbitrary data that was sent to the {universalReceiver(...)} function.\",\"returnedValue\":\"The value returned by the {universalReceiver(...)} function.\",\"typeId\":\"A `bytes32` unique identifier (= _\\\"hook\\\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\",\"value\":\"The amount sent to the {universalReceiver(...)} function.\"}}},\"kind\":\"dev\",\"methods\":{\"universalReceiver(bytes32,bytes)\":{\"details\":\"Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\",\"params\":{\"data\":\"The arbitrary data received with the call.\",\"typeId\":\"The hash of a specific standard or a hook.\"}}},\"version\":1},\"userdoc\":{\"events\":{\"UniversalReceiver(address,uint256,bytes32,bytes,bytes)\":{\"notice\":\"Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\"}},\"kind\":\"user\",\"methods\":{\"isValidSignature(bytes32,bytes)\":{\"notice\":\"Verifies that the signer is the owner of the signing contract.\"},\"supportsInterface(bytes4)\":{\"notice\":\"override the supportsInterface function from ERC165\"},\"universalReceiver(bytes32,bytes)\":{\"notice\":\"Reacted on received notification with `typeId` & `data`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/mocks/UPMock.sol\":\"UPMock\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\":{\"content\":\"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title The interface for ERC725Y sub-standard, a generic data key/value store.\\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time.\\n * It is intended to standardise certain data key/value pairs to allow automated read and writes from/to the contract storage.\\n */\\ninterface IERC725Y is IERC165 {\\n    /**\\n     * @notice The following data key/value pair has been changed in the ERC725Y storage: Data key: `dataKey`, data value: `dataValue`.\\n     * @dev Emitted when data at a specific `dataKey` was changed to a new value `dataValue`.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data key `dataKey` returned the following value: `dataValue`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at a specific data key `dataKey`.\\n     * @param dataKey The data key for which to retrieve the value.\\n     * @return dataValue The bytes value stored under the specified data key.\\n     */\\n    function getData(\\n        bytes32 dataKey\\n    ) external view returns (bytes memory dataValue);\\n\\n    /**\\n     * @notice Reading the ERC725Y storage for data keys `dataKeys` returned the following values: `dataValues`.\\n     * @dev Get in the ERC725Y storage the bytes data stored at multiple data keys `dataKeys`.\\n     * @param dataKeys The array of keys which values to retrieve\\n     * @return dataValues The array of data stored at multiple keys\\n     */\\n    function getDataBatch(\\n        bytes32[] memory dataKeys\\n    ) external view returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Setting the following data key value pair in the ERC725Y storage. Data key: `dataKey`, data value: `dataValue`.\\n     *\\n     * @dev Sets a single bytes value `dataValue` in the ERC725Y storage for a specific data key `dataKey`.\\n     * The function is marked as payable to enable flexibility on child contracts. For instance to implement\\n     * a fee mechanism for setting specific data.\\n     *\\n     * @param dataKey The data key for which to set a new value.\\n     * @param dataValue The new bytes value to set.\\n     */\\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\\n\\n    /**\\n     * @notice Setting the following data key value pairs in the ERC725Y storage. Data keys: `dataKeys`, data values: `dataValues`.\\n     *\\n     * @dev Batch data setting function that behaves the same as {setData} but allowing to set multiple data key/value pairs in the ERC725Y storage in the same transaction.\\n     *\\n     * @param dataKeys An array of data keys to set bytes values for.\\n     * @param dataValues An array of bytes values to set for each `dataKeys`.\\n     */\\n    function setDataBatch(\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0xa47c9e3eba0c733a1685b9fa309f753540c89ad2dca73236a2c953e7f5680e7b\",\"license\":\"CC0-1.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp0-contracts/contracts/LSP0Constants.sol\\\";\\n\",\"keccak256\":\"0x82f1c5d5689df750d081fef3b0d48faca2f13f4b2b6b67426deb9da1060dc3db\",\"license\":\"Apache-2.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\\\";\\n\",\"keccak256\":\"0x39114a8dc3ec9c8ddd22cb0219614aa82565fe8338acfbd99cdb7c9ad55b1d1c\",\"license\":\"Apache-2.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp1-contracts/contracts/LSP1Constants.sol\\\";\\n\",\"keccak256\":\"0x2fbc59802e5ab01aeb72fdc69fca1bbb420eeeb1c4bc009a1e2a7b78b491999d\",\"license\":\"Apache-2.0\"},\"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\nimport \\\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\\\";\\n\",\"keccak256\":\"0xf24c0f30ffdc2540755ae809effdba80029f8418e2b0c9f72b878aad50ba1b72\",\"license\":\"Apache-2.0\"},\"@lukso/lsp0-contracts/contracts/LSP0Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// --- ERC165 interface ids\\nbytes4 constant _INTERFACEID_LSP0 = 0x24871b3d;\\nbytes4 constant _INTERFACEID_ERC1271 = 0x1626ba7e;\\n\\n// ERC1271 - Standard Signature Validation\\nbytes4 constant _ERC1271_SUCCESSVALUE = 0x1626ba7e;\\nbytes4 constant _ERC1271_FAILVALUE = 0xffffffff;\\n\\n// --- Native Token Type Id\\n\\n// keccak256('LSP0ValueReceived')\\nbytes32 constant _TYPEID_LSP0_VALUE_RECEIVED = 0x9c4705229491d365fb5434052e12a386d6771d976bea61070a8c694e8affea3d;\\n\\n// Ownership Transfer Type IDs\\n\\n// keccak256('LSP0OwnershipTransferStarted')\\nbytes32 constant _TYPEID_LSP0_OwnershipTransferStarted = 0xe17117c9d2665d1dbeb479ed8058bbebde3c50ac50e2e65619f60006caac6926;\\n\\n// keccak256('LSP0OwnershipTransferred_SenderNotification')\\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_SenderNotification = 0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814;\\n\\n// keccak256('LSP0OwnershipTransferred_RecipientNotification')\\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_RecipientNotification = 0xceca317f109c43507871523e82dc2a3cc64dfa18f12da0b6db14f6e23f995538;\\n\",\"keccak256\":\"0x9066f85dcef006b7896a367fd08fd0a62706a32457be6859191f15f5e865d049\",\"license\":\"Apache-2.0\"},\"@lukso/lsp1-contracts/contracts/ILSP1UniversalReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Interface of the LSP1 - Universal Receiver standard, an entry function for a contract to receive arbitrary information.\\n * @dev LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received.\\n */\\ninterface ILSP1UniversalReceiver {\\n    /**\\n     * @dev Emitted when the {universalReceiver} function was called with a specific `typeId` and some `receivedData`\\n     * @notice Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`.\\n     *\\n     * @param from The address of the EOA or smart contract that called the {universalReceiver(...)} function.\\n     * @param value The amount sent to the {universalReceiver(...)} function.\\n     * @param typeId A `bytes32` unique identifier (= _\\\"hook\\\"_)that describe the type of notification, information or transaction received by the contract. Can be related to a specific standard or a hook.\\n     * @param receivedData Any arbitrary data that was sent to the {universalReceiver(...)} function.\\n     * @param returnedValue The value returned by the {universalReceiver(...)} function.\\n     */\\n    event UniversalReceiver(\\n        address indexed from,\\n        uint256 indexed value,\\n        bytes32 indexed typeId,\\n        bytes receivedData,\\n        bytes returnedValue\\n    );\\n\\n    /**\\n     * @dev Generic function that can be used to notify the contract about specific incoming transactions or events like asset transfers, vault transfers, etc. Allows for custom on-chain and off-chain reactions based on the `typeId` and `data`.\\n     * @notice Reacted on received notification with `typeId` & `data`.\\n     *\\n     * @param typeId The hash of a specific standard or a hook.\\n     * @param data The arbitrary data received with the call.\\n     *\\n     * @custom:events {UniversalReceiver} event.\\n     */\\n    function universalReceiver(\\n        bytes32 typeId,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x5b8764a678dc9d6673eafa8ad0ee6053cdea30acb58015bdf9c93f9f1788b49b\",\"license\":\"Apache-2.0\"},\"@lukso/lsp1-contracts/contracts/LSP1Constants.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// --- ERC165 interface ids\\nbytes4 constant _INTERFACEID_LSP1 = 0x6bb56a14;\\nbytes4 constant _INTERFACEID_LSP1_DELEGATE = 0xa245bbda;\\n\\n// --- ERC725Y Data Keys\\n\\n// bytes10(keccak256('LSP1UniversalReceiverDelegate'))\\nbytes10 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX = 0x0cfc51aec37c55a4d0b1;\\n\\n// keccak256('LSP1UniversalReceiverDelegate')\\nbytes32 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY = 0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47;\\n\",\"keccak256\":\"0x0f87fc38243fc70316e22814f5a79d9c0770a39f64077cbc6fb5fddfa1d4c23c\",\"license\":\"Apache-2.0\"},\"@lukso/lsp8-contracts/contracts/ILSP8IdentifiableDigitalAsset.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// interfaces\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {\\n    IERC725Y\\n} from \\\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\\\";\\n\\n/**\\n * @title Interface of the LSP8 - Identifiable Digital Asset standard, a non-fungible digital asset.\\n */\\ninterface ILSP8IdentifiableDigitalAsset is IERC165, IERC725Y {\\n    // --- Events\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from the `from` to the `to` address.\\n     * @param operator The address of operator that sent the `tokenId`\\n     * @param from The previous owner of the `tokenId`\\n     * @param to The new owner of `tokenId`\\n     * @param tokenId The tokenId that was transferred\\n     * @param force If the token transfer enforces the `to` recipient address to be a contract that implements the LSP1 standard or not.\\n     * @param data Any additional data the caller included by the caller during the transfer, and sent in the hooks to the `from` and `to` addresses.\\n     */\\n    event Transfer(\\n        address operator,\\n        address indexed from,\\n        address indexed to,\\n        bytes32 indexed tokenId,\\n        bool force,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` enables `operator` to transfer or burn the `tokenId`.\\n     * @param operator The address authorized as an operator.\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` address has access on behalf of `tokenOwner`.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorAuthorizationChanged(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when `tokenOwner` disables `operator` to transfer or burn `tokenId` on its behalf.\\n     * @param operator The address revoked from the operator array ({getOperatorsOf}).\\n     * @param tokenOwner The owner of the `tokenId`.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notified Bool indicating whether the operator has been notified or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     */\\n    event OperatorRevoked(\\n        address indexed operator,\\n        address indexed tokenOwner,\\n        bytes32 indexed tokenId,\\n        bool notified,\\n        bytes operatorNotificationData\\n    );\\n\\n    /**\\n     * @dev Emitted when setting data for `tokenId`.\\n     * @param tokenId The tokenId which data is set for.\\n     * @param dataKey The data key for which a bytes value is set.\\n     * @param dataValue The value to set for the given data key.\\n     */\\n    event TokenIdDataChanged(\\n        bytes32 indexed tokenId,\\n        bytes32 indexed dataKey,\\n        bytes dataValue\\n    );\\n\\n    // --- Token queries\\n\\n    /**\\n     * @dev Returns the number of existing tokens that have been minted in this contract.\\n     * @return The number of existing tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // --- Token owner queries\\n\\n    /**\\n     * @dev Get the number of token IDs owned by `tokenOwner`.\\n\\n     * @param tokenOwner The address to query     *\\n     * @return The total number of token IDs that `tokenOwner` owns.\\n     */\\n    function balanceOf(address tokenOwner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the address that owns a given `tokenId`.\\n     *\\n     * @param tokenId The token ID to query the owner for.\\n     * @return The owner address of the given `tokenId`.\\n     *\\n     * @custom:requirements `tokenId` must exist.\\n     * @custom:info if the `tokenId` is not owned by any address, the returned address will be `address(0)`\\n     */\\n    function tokenOwnerOf(bytes32 tokenId) external view returns (address);\\n\\n    /**\\n     * @dev Returns the list of token IDs that the `tokenOwner` address owns.\\n     * @param tokenOwner The address that we want to get the list of token IDs for.\\n     * @return An array of `bytes32[] tokenIds` owned by `tokenOwner`.\\n     */\\n    function tokenIdsOf(\\n        address tokenOwner\\n    ) external view returns (bytes32[] memory);\\n\\n    // --- TokenId Metadata functionality\\n\\n    /**\\n     * @notice Retrieves data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to retrieve.\\n     * @return dataValues The data value associated with the given `tokenId` and `dataKey`.\\n     */\\n    function getDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey\\n    ) external returns (bytes memory dataValues);\\n\\n    /**\\n     * @notice Retrieves data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @return dataValues An array of data values for each pair of `tokenId` and `dataKey`.\\n     */\\n    function getDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys\\n    ) external returns (bytes[] memory dataValues);\\n\\n    /**\\n     * @notice Sets data for a specific `tokenId` and `dataKey`.\\n     * @param tokenId The unique identifier for a token.\\n     * @param dataKey The key for the data to set.\\n     * @param dataValue The value to set for the given data key.\\n     * @custom:events {TokenIdDataChanged} event.\\n     */\\n    function setDataForTokenId(\\n        bytes32 tokenId,\\n        bytes32 dataKey,\\n        bytes memory dataValue\\n    ) external;\\n\\n    /**\\n     * @notice Sets data in batch for multiple `tokenId` and `dataKey` pairs.\\n     * @param tokenIds An array of token IDs.\\n     * @param dataKeys An array of data keys corresponding to the token IDs.\\n     * @param dataValues An array of values to set for the given data keys.\\n     * @custom:events {TokenIdDataChanged} event for each pair.\\n     */\\n    function setDataBatchForTokenIds(\\n        bytes32[] memory tokenIds,\\n        bytes32[] memory dataKeys,\\n        bytes[] memory dataValues\\n    ) external;\\n\\n    // --- Operator functionality\\n\\n    /**\\n     * @dev Allow an `operator` address to transfer or burn a specific `tokenId` on behalf of its token owner. See {isOperatorFor}.\\n     * Notify the operator based on the LSP1-UniversalReceiver standard\\n     *\\n     * @param operator The address to authorize as an operator.\\n     * @param tokenId The token ID operator has access to.\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller MUST be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorAuthorizationChanged} event.\\n     */\\n    function authorizeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Remove access of `operator` for a given `tokenId`, disallowing it to transfer `tokenId` on behalf of its owner.\\n     * See also {isOperatorFor}.\\n     *\\n     * @param operator The address to revoke as an operator.\\n     * @param tokenId The tokenId `operator` is revoked from operating on.\\n     * @param notify Boolean indicating whether to notify the operator or not\\n     * @param operatorNotificationData The data to notify the operator about via LSP1.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the {tokenOwnerOf} `tokenId`.\\n     * - the owner of a `tokenId` cannot grant revoke itself as an `operator` (`operator` cannot be the calling address).\\n     * - `operator` cannot be the zero address.\\n     *\\n     * @custom:events {OperatorRevoked} event with address of the operator being revoked for the caller (token owner)..\\n     */\\n    function revokeOperator(\\n        address operator,\\n        bytes32 tokenId,\\n        bool notify,\\n        bytes memory operatorNotificationData\\n    ) external;\\n\\n    /**\\n     * @dev Returns whether `operator` address is an operator for a given `tokenId`.\\n     *\\n     * @param operator The address to query operator status for.\\n     * @param tokenId The token ID to check if `operator` is allowed to operate on.\\n     *\\n     * @return `true` if `operator` is an operator for `tokenId`, `false` otherwise.\\n     *\\n     * @custom:requirements\\n     * - `tokenId` must exist.\\n     * - caller must be the current {tokenOwnerOf} `tokenId`.\\n     *\\n     * @custom:info The tokenOwner is its own operator.\\n     */\\n    function isOperatorFor(\\n        address operator,\\n        bytes32 tokenId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns all `operator` addresses that are allowed to transfer or burn a specific `tokenId` on behalf of its owner.\\n     *\\n     * @param tokenId The token ID to get the operators for.\\n     * @return An array of operators allowed to transfer or burn a specific `tokenId`.\\n     *\\n     * Requirements\\n     * - `tokenId` must exist.\\n     */\\n    function getOperatorsOf(\\n        bytes32 tokenId\\n    ) external view returns (address[] memory);\\n\\n    // --- Transfer functionality\\n\\n    /**\\n     * @dev Transfer a given `tokenId` token from the `from` address to the `to` address.\\n     *\\n     * If operators are set for a specific `tokenId`, all the operators are revoked after the tokenId have been transferred.\\n     *\\n     * The `force` parameter MUST be set to `true` when transferring tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 standard.\\n     *\\n     * @param from The address that owns the given `tokenId`.\\n     * @param to The address that will receive the `tokenId`.\\n     * @param tokenId The token ID to transfer.\\n     * @param force When set to `true`, the `to` address CAN be any addres.\\n     * When set to `false`, the `to` address MUST be a contract that supports the LSP1 UniversalReceiver standard.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks of the `from` and `to` addresses.\\n     *\\n     * @custom:requirements\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` and `to` cannot be the same address (`from` cannot send the `tokenId` to itself).\\n     * - `from` must own the given `tokenId`.\\n     * - If the caller is not `from`, it must be an operator for the `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} event when the `tokenId` is successfully transferred.\\n     *\\n     * @custom:hint The `force` parameter **MUST be set to `true`** to transfer tokens to Externally Owned Accounts (EOAs)\\n     * or contracts that do not implement the LSP1 Universal Receiver Standard. Otherwise the function will revert making the transfer fail.\\n     *\\n     * @custom:info if the `to` address is a contract that implements LSP1, it will always be notified via its `universalReceiver(...)` function, regardless if `force` is set to `true` or `false`.\\n     *\\n     * @custom:warning Be aware that when either the sender or the recipient can have logic that revert in their `universalReceiver(...)` function when being notified.\\n     * This even if the `force` was set to `true`.\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        bytes32 tokenId,\\n        bool force,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers multiple tokens at once based on the arrays of `from`, `to` and `tokenId`.\\n     * If any transfer fails, the whole call will revert.\\n     *\\n     * @param from An array of sending addresses.\\n     * @param to An array of recipient addresses.\\n     * @param tokenId An array of token IDs to transfer.\\n     * @param force When set to `true`, `to` may be any address.\\n     * When set to `false`, `to` must be a contract that supports the LSP1 standard and not revert.\\n     * @param data Any additional data the caller wants included in the emitted event, and sent in the hooks to the `from` and `to` addresses.\\n     *\\n     *\\n     * @custom:requirements\\n     * - The arrays of `from`, `to` and `tokenId` must have the same length.\\n     * - no values in the `from` array can be the zero address.\\n     * - no values in the `to` array can be the zero address.\\n     * - `from` and `to` cannot be the same address at the same index on each arrays.\\n     * - each `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be an operator of each `tokenId`.\\n     *\\n     * @custom:events\\n     * - {Transfer} events on each successful token transfer.\\n     */\\n    function transferBatch(\\n        address[] memory from,\\n        address[] memory to,\\n        bytes32[] memory tokenId,\\n        bool[] memory force,\\n        bytes[] memory data\\n    ) external;\\n\\n    /**\\n     * @notice Executing the following batch of abi-encoded function calls on the contract: `data`.\\n     *\\n     * @dev Allows a caller to batch different function calls in one call. Perform a `delegatecall` on self, to call different functions with preserving the context.\\n     * @param data An array of ABI encoded function calls to be called on the contract.\\n     * @return results An array of abi-encoded data returned by the functions executed.\\n     */\\n    function batchCalls(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory results);\\n}\\n\",\"keccak256\":\"0x16dccaeb35168c4e61763a2c35b075eeed7505661b10fc9c16194af6eb3751ad\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0x9e8778b14317ba9e256c30a76fd6c32b960af621987f56069e1e819c77c6a133\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x4296879f55019b23e135000eb36896057e7101fb7fb859c5ef690cf14643757b\",\"license\":\"MIT\"},\"contracts/interfaces/IShirts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {ILSP8IdentifiableDigitalAsset as ILSP8} from \\\"@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/ILSP8IdentifiableDigitalAsset.sol\\\";\\ninterface IShirts is ILSP8 {\\n    event ShirtsMinted(address _recipient, uint256 _amount);\\n\\n    function mint(\\n        address _recipient,\\n        uint256 _amount\\n    ) external payable;\\n    \\n    function getPrizePool() external view returns (address prizePool);\\n\\n    function getPrice() external view returns (uint256 price);\\n}\",\"keccak256\":\"0x4e3bf68e661345d6da97b438b69e498842a75f160579b20c32306eb755407a0e\",\"license\":\"MIT\"},\"contracts/mocks/UPMock.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.4;\\n\\n// interfaces\\nimport {\\n    ILSP1UniversalReceiver\\n} from \\\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\\\";\\n\\n// modules\\nimport {\\n    ERC165\\n} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n// constants\\nimport {_INTERFACEID_LSP1} from \\\"@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol\\\";\\nimport {_INTERFACEID_LSP0} from \\\"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol\\\";\\n\\nimport {IShirts} from \\\"../interfaces/IShirts.sol\\\";\\n\\ninterface BPunX {\\n    function mint(uint256 _amount) external payable;\\n}\\ncontract UPMock is ERC165, ILSP1UniversalReceiver {\\n    \\n    /// override the supportsInterface function from ERC165\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == _INTERFACEID_LSP1 ||\\n            interfaceId == _INTERFACEID_LSP0 ||\\n            super.supportsInterface(interfaceId);\\n    }\\n    function universalReceiver(\\n        bytes32 typeId,\\n        bytes memory data\\n    ) external payable override returns (bytes memory returnValue) {\\n        emit UniversalReceiver(msg.sender, msg.value, typeId, data, \\\"\\\");\\n\\n        return \\\"thanks for calling\\\";\\n    }\\n    /**\\n     * @notice Verifies that the signer is the owner of the signing contract.\\n     */\\n    function isValidSignature(\\n        bytes32 /* messageHash */,\\n        bytes calldata /* signature */\\n    ) external pure returns (bytes4) {\\n        // always return true (just for testing)\\n        return 0x1626ba7e;\\n    }\\n    function transfer(\\n        address shirts,\\n        address from,\\n        address to,\\n        bytes32 tokenId,\\n        bool force,\\n        bytes memory data\\n    ) external {\\n        IShirts(shirts).transfer(from, to, tokenId, force, data);\\n    }\\n    function fund() external payable {}\\n    function getBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n    receive() external payable {}\\n    fallback() external payable {}\\n}\",\"keccak256\":\"0xde0394b28362567783cd1a4ec10640ac33a81440f2a80bfa611f5b5f08be635c\",\"license\":\"Apache-2.0\"}},\"version\":1}","storageLayout":{"storage":[],"types":null},"userdoc":{"events":{"UniversalReceiver(address,uint256,bytes32,bytes,bytes)":{"notice":"Address `from` called the `universalReceiver(...)` function while sending `value` LYX. Notification type (typeId): `typeId` - Data received: `receivedData`."}},"kind":"user","methods":{"isValidSignature(bytes32,bytes)":{"notice":"Verifies that the signer is the owner of the signing contract."},"supportsInterface(bytes4)":{"notice":"override the supportsInterface function from ERC165"},"universalReceiver(bytes32,bytes)":{"notice":"Reacted on received notification with `typeId` & `data`."}},"version":1}}}}}}